webpackHotUpdate("main",{

/***/ "./src/line_cursor.js":
/*!****************************!*\
  !*** ./src/line_cursor.js ***!
  \****************************/
/*! exports provided: LineCursor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LineCursor\", function() { return LineCursor; });\n/* harmony import */ var blockly__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly */ \"./node_modules/blockly/dist/index.js\");\n/* harmony import */ var blockly__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly__WEBPACK_IMPORTED_MODULE_0__);\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The class representing a line cursor.\n * A line cursor traverses the blocks as if they were\n * lines of code in a text editor.\n * Previous and next go up and down lines. In and out go\n * through the elements in a line.\n * @author aschmiedt@google.com (Abby Schmiedt)\n */\n\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n/**\n * Class for a line cursor.\n * This will allow the user to get to all nodes in the AST by hitting next or\n * previous.\n * @constructor\n * @extends {Blockly.BasicCursor}\n */\n\nvar LineCursor = /*#__PURE__*/function (_Blockly$BasicCursor) {\n  _inherits(LineCursor, _Blockly$BasicCursor);\n\n  var _super = _createSuper(LineCursor);\n\n  /**\n   * Constructor for a line cursor.\n   */\n  function LineCursor() {\n    _classCallCheck(this, LineCursor);\n\n    return _super.call(this);\n  }\n  /**\n   * Find the next node in the pre order traversal.\n   * @return {Blockly.ASTNode} The next node, or null if the current node is\n   *     not set or there is no next value.\n   * @override\n   */\n\n\n  _createClass(LineCursor, [{\n    key: \"next\",\n    value: function next() {\n      var curNode = this.getCurNode();\n\n      if (!curNode) {\n        return null;\n      }\n\n      var newNode = this.getNextNode_(curNode, this.validLineNode_); // Skip the input or next value if there is a connected block.\n\n      if (newNode && (newNode.getType() == blockly__WEBPACK_IMPORTED_MODULE_0__[\"ASTNode\"].types.INPUT || newNode.getType() == blockly__WEBPACK_IMPORTED_MODULE_0__[\"ASTNode\"].types.NEXT) && newNode.getLocation().targetBlock()) {\n        newNode = this.getNextNode_(newNode, this.validLineNode_);\n      }\n\n      if (newNode) {\n        this.setCurNode(newNode);\n      }\n\n      return newNode;\n    }\n    /**\n     * Find the previous node in the pre order traversal.\n     * @return {Blockly.ASTNode} The previous node, or null if the current node\n     *     is not set or there is no previous value.\n     * @override\n     */\n\n  }, {\n    key: \"prev\",\n    value: function prev() {\n      var curNode = this.getCurNode();\n\n      if (!curNode) {\n        return null;\n      }\n\n      var newNode = this.getPreviousNode_(curNode, this.validLineNode_);\n\n      if (newNode && (newNode.getType() == blockly__WEBPACK_IMPORTED_MODULE_0__[\"ASTNode\"].types.INPUT || newNode.getType() == blockly__WEBPACK_IMPORTED_MODULE_0__[\"ASTNode\"].types.NEXT) && newNode.getLocation().targetBlock()) {\n        newNode = this.getPreviousNode_(newNode, this.validLineNode_);\n      }\n\n      if (newNode) {\n        this.setCurNode(newNode);\n      }\n\n      return newNode;\n    }\n    /**\n     * For a basic cursor we only have the ability to go next and previous, so\n     * in will also allow the user to get to the next node in the pre order\n     * traversal.\n     * @return {Blockly.ASTNode} The next node, or null if the current node is\n     *     not set or there is no next value.\n     * @override\n     */\n\n  }, {\n    key: \"in\",\n    value: function _in() {\n      var curNode = this.getCurNode();\n\n      if (!curNode) {\n        return null;\n      }\n\n      var newNode = this.getNextNode_(curNode, this.validInLineNode_);\n\n      if (newNode) {\n        this.setCurNode(newNode);\n      }\n\n      return newNode;\n    }\n    /**\n     * For a basic cursor we only have the ability to go next and previous, so\n     * out will allow the user to get to the previous node in the pre order\n     * traversal.\n     * @return {Blockly.ASTNode} The previous node, or null if the current\n     *     node is not set or there is no previous value.\n     * @override\n     */\n\n  }, {\n    key: \"out\",\n    value: function out() {\n      var curNode = this.getCurNode();\n\n      if (!curNode) {\n        return null;\n      }\n\n      var newNode = this.getPreviousNode_(curNode, this.validInLineNode_);\n\n      if (newNode) {\n        this.setCurNode(newNode);\n      }\n\n      return newNode;\n    }\n    /**\n     * Meant to traverse by lines of code. This is blocks, statement inputs and\n     * next connections.\n     * @param {Blockly.ASTNode} node The AST node to check whether it is valid.\n     * @return {boolean} True if the node should be visited, false otherwise.\n     * @private\n     */\n\n  }, {\n    key: \"validLineNode_\",\n    value: function validLineNode_(node) {\n      if (!node) {\n        return false;\n      }\n\n      var isValid = false;\n      var location = node.getLocation();\n      var type = node && node.getType();\n\n      if (type == blockly__WEBPACK_IMPORTED_MODULE_0__[\"ASTNode\"].types.PREVIOUS) {\n        isValid = true;\n      } else if (type == blockly__WEBPACK_IMPORTED_MODULE_0__[\"ASTNode\"].types.INPUT && location.type == blockly__WEBPACK_IMPORTED_MODULE_0__[\"NEXT_STATEMENT\"]) {\n        isValid = true;\n      } else if (type == blockly__WEBPACK_IMPORTED_MODULE_0__[\"ASTNode\"].types.NEXT) {\n        isValid = true;\n      } else if (type === blockly__WEBPACK_IMPORTED_MODULE_0__[\"ASTNode\"].types.OUTPUT) {\n        if (!location.targetConnection) {\n          isValid = true;\n        }\n      }\n\n      return isValid;\n    }\n    /**\n     * Meant to traverse within a block. These are fields and input values.\n     * @param {Blockly.ASTNode} node The AST node to check whether it is valid.\n     * @return {boolean} True if the node should be visited, false otherwise.\n     * @private\n     */\n\n  }, {\n    key: \"validInLineNode_\",\n    value: function validInLineNode_(node) {\n      if (!node) {\n        return false;\n      }\n\n      var isValid = false;\n      var location = node.getLocation();\n      var type = node && node.getType();\n\n      if (type === blockly__WEBPACK_IMPORTED_MODULE_0__[\"ASTNode\"].types.FIELD) {\n        isValid = true;\n      } else if (type === blockly__WEBPACK_IMPORTED_MODULE_0__[\"ASTNode\"].types.INPUT && location.type === blockly__WEBPACK_IMPORTED_MODULE_0__[\"INPUT_VALUE\"]) {\n        isValid = true;\n      } else if (type == blockly__WEBPACK_IMPORTED_MODULE_0__[\"ASTNode\"].types.OUTPUT) {\n        isValid = true;\n      } else if (type == blockly__WEBPACK_IMPORTED_MODULE_0__[\"ASTNode\"].types.STACK) {\n        isValid = true;\n      }\n\n      return isValid;\n    }\n  }]);\n\n  return LineCursor;\n}(blockly__WEBPACK_IMPORTED_MODULE_0__[\"BasicCursor\"]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGluZV9jdXJzb3IuanM/MzczNSJdLCJuYW1lcyI6WyJMaW5lQ3Vyc29yIiwiY3VyTm9kZSIsImdldEN1ck5vZGUiLCJuZXdOb2RlIiwiZ2V0TmV4dE5vZGVfIiwidmFsaWRMaW5lTm9kZV8iLCJnZXRUeXBlIiwiQmxvY2tseSIsInR5cGVzIiwiSU5QVVQiLCJORVhUIiwiZ2V0TG9jYXRpb24iLCJ0YXJnZXRCbG9jayIsInNldEN1ck5vZGUiLCJnZXRQcmV2aW91c05vZGVfIiwidmFsaWRJbkxpbmVOb2RlXyIsIm5vZGUiLCJpc1ZhbGlkIiwibG9jYXRpb24iLCJ0eXBlIiwiUFJFVklPVVMiLCJPVVRQVVQiLCJ0YXJnZXRDb25uZWN0aW9uIiwiRklFTEQiLCJTVEFDSyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRWI7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDTyxJQUFNQSxVQUFiO0FBQUE7O0FBQUE7O0FBQ0U7QUFDRjtBQUNBO0FBQ0Usd0JBQWM7QUFBQTs7QUFBQTtBQUViO0FBQ0Q7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFaQTtBQUFBO0FBQUEsMkJBYVM7QUFDTCxVQUFNQyxPQUFPLEdBQUcsS0FBS0MsVUFBTCxFQUFoQjs7QUFDQSxVQUFJLENBQUNELE9BQUwsRUFBYztBQUNaLGVBQU8sSUFBUDtBQUNEOztBQUNELFVBQUlFLE9BQU8sR0FBRyxLQUFLQyxZQUFMLENBQWtCSCxPQUFsQixFQUEyQixLQUFLSSxjQUFoQyxDQUFkLENBTEssQ0FPTDs7QUFDQSxVQUFJRixPQUFPLEtBQUtBLE9BQU8sQ0FBQ0csT0FBUixNQUFxQkMsK0NBQUEsQ0FBZ0JDLEtBQWhCLENBQXNCQyxLQUEzQyxJQUNa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QUFnQkMsS0FBaEIsQ0FBc0JnQixLQUFsQyxFQUF5QztBQUM5Q1AsZUFBTyxHQUFHLElBQVY7QUFDRDs7QUFDRCxhQUFPQSxPQUFQO0FBQ0Q7QUF4Skg7O0FBQUE7QUFBQSxFQUFnQ1YsbURBQWhDIiwiZmlsZSI6Ii4vc3JjL2xpbmVfY3Vyc29yLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGhlIGNsYXNzIHJlcHJlc2VudGluZyBhIGxpbmUgY3Vyc29yLlxuICogQSBsaW5lIGN1cnNvciB0cmF2ZXJzZXMgdGhlIGJsb2NrcyBhcyBpZiB0aGV5IHdlcmVcbiAqIGxpbmVzIG9mIGNvZGUgaW4gYSB0ZXh0IGVkaXRvci5cbiAqIFByZXZpb3VzIGFuZCBuZXh0IGdvIHVwIGFuZCBkb3duIGxpbmVzLiBJbiBhbmQgb3V0IGdvXG4gKiB0aHJvdWdoIHRoZSBlbGVtZW50cyBpbiBhIGxpbmUuXG4gKiBAYXV0aG9yIGFzY2htaWVkdEBnb29nbGUuY29tIChBYmJ5IFNjaG1pZWR0KVxuICovXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCAqIGFzIEJsb2NrbHkgZnJvbSAnYmxvY2tseSc7XG5cbi8qKlxuICogQ2xhc3MgZm9yIGEgbGluZSBjdXJzb3IuXG4gKiBUaGlzIHdpbGwgYWxsb3cgdGhlIHVzZXIgdG8gZ2V0IHRvIGFsbCBub2RlcyBpbiB0aGUgQVNUIGJ5IGhpdHRpbmcgbmV4dCBvclxuICogcHJldmlvdXMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtCbG9ja2x5LkJhc2ljQ3Vyc29yfVxuICovXG5leHBvcnQgY2xhc3MgTGluZUN1cnNvciBleHRlbmRzIEJsb2NrbHkuQmFzaWNDdXJzb3Ige1xuICAvKipcbiAgICogQ29uc3RydWN0b3IgZm9yIGEgbGluZSBjdXJzb3IuXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kIHRoZSBuZXh0IG5vZGUgaW4gdGhlIHByZSBvcmRlciB0cmF2ZXJzYWwuXG4gICAqIEByZXR1cm4ge0Jsb2NrbHkuQVNUTm9kZX0gVGhlIG5leHQgbm9kZSwgb3IgbnVsbCBpZiB0aGUgY3VycmVudCBub2RlIGlzXG4gICAqICAgICBub3Qgc2V0IG9yIHRoZXJlIGlzIG5vIG5leHQgdmFsdWUuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgbmV4dCgpIHtcbiAgICBjb25zdCBjdXJOb2RlID0gdGhpcy5nZXRDdXJOb2RlKCk7XG4gICAgaWYgKCFjdXJOb2RlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0IG5ld05vZGUgPSB0aGlzLmdldE5leHROb2RlXyhjdXJOb2RlLCB0aGlzLnZhbGlkTGluZU5vZGVfKTtcblxuICAgIC8vIFNraXAgdGhlIGlucHV0IG9yIG5leHQgdmFsdWUgaWYgdGhlcmUgaXMgYSBjb25uZWN0ZWQgYmxvY2suXG4gICAgaWYgKG5ld05vZGUgJiYgKG5ld05vZGUuZ2V0VHlwZSgpID09IEJsb2NrbHkuQVNUTm9kZS50eXBlcy5JTlBVVCB8fFxuICAgICAgICBuZXdOb2RlLmdldFR5cGUoKSA9PSBCbG9ja2x5LkFTVE5vZGUudHlwZXMuTkVYVCkgJiZcbiAgICAgICAgbmV3Tm9kZS5nZXRMb2NhdGlvbigpLnRhcmdldEJsb2NrKCkpIHtcbiAgICAgIG5ld05vZGUgPSB0aGlzLmdldE5leHROb2RlXyhuZXdOb2RlLCB0aGlzLnZhbGlkTGluZU5vZGVfKTtcbiAgICB9XG4gICAgaWYgKG5ld05vZGUpIHtcbiAgICAgIHRoaXMuc2V0Q3VyTm9kZShuZXdOb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld05vZGU7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBwcmV2aW91cyBub2RlIGluIHRoZSBwcmUgb3JkZXIgdHJhdmVyc2FsLlxuICAgKiBAcmV0dXJuIHtCbG9ja2x5LkFTVE5vZGV9IFRoZSBwcmV2aW91cyBub2RlLCBvciBudWxsIGlmIHRoZSBjdXJyZW50IG5vZGVcbiAgICogICAgIGlzIG5vdCBzZXQgb3IgdGhlcmUgaXMgbm8gcHJldmlvdXMgdmFsdWUuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgcHJldigpIHtcbiAgICBjb25zdCBjdXJOb2RlID0gdGhpcy5nZXRDdXJOb2RlKCk7XG4gICAgaWYgKCFjdXJOb2RlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0IG5ld05vZGUgPSB0aGlzLmdldFByZXZpb3VzTm9kZV8oY3VyTm9kZSwgdGhpcy52YWxpZExpbmVOb2RlXyk7XG5cbiAgICBpZiAobmV3Tm9kZSAmJiAobmV3Tm9kZS5nZXRUeXBlKCkgPT0gQmxvY2tseS5BU1ROb2RlLnR5cGVzLklOUFVUIHx8XG4gICAgICBuZXdOb2RlLmdldFR5cGUoKSA9PSBCbG9ja2x5LkFTVE5vZGUudHlwZXMuTkVYVCkgJiZcbiAgICAgIG5ld05vZGUuZ2V0TG9jYXRpb24oKS50YXJnZXRCbG9jaygpKSB7XG4gICAgICBuZXdOb2RlID0gdGhpcy5nZXRQcmV2aW91c05vZGVfKG5ld05vZGUsIHRoaXMudmFsaWRMaW5lTm9kZV8pO1xuICAgIH1cblxuICAgIGlmIChuZXdOb2RlKSB7XG4gICAgICB0aGlzLnNldEN1ck5vZGUobmV3Tm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXdOb2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvciBhIGJhc2ljIGN1cnNvciB3ZSBvbmx5IGhhdmUgdGhlIGFiaWxpdHkgdG8gZ28gbmV4dCBhbmQgcHJldmlvdXMsIHNvXG4gICAqIGluIHdpbGwgYWxzbyBhbGxvdyB0aGUgdXNlciB0byBnZXQgdG8gdGhlIG5leHQgbm9kZSBpbiB0aGUgcHJlIG9yZGVyXG4gICAqIHRyYXZlcnNhbC5cbiAgICogQHJldHVybiB7QmxvY2tseS5BU1ROb2RlfSBUaGUgbmV4dCBub2RlLCBvciBudWxsIGlmIHRoZSBjdXJyZW50IG5vZGUgaXNcbiAgICogICAgIG5vdCBzZXQgb3IgdGhlcmUgaXMgbm8gbmV4dCB2YWx1ZS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBpbigpIHtcbiAgICBjb25zdCBjdXJOb2RlID0gdGhpcy5nZXRDdXJOb2RlKCk7XG4gICAgaWYgKCFjdXJOb2RlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbmV3Tm9kZSA9IHRoaXMuZ2V0TmV4dE5vZGVfKGN1ck5vZGUsIHRoaXMudmFsaWRJbkxpbmVOb2RlXyk7XG5cbiAgICBpZiAobmV3Tm9kZSkge1xuICAgICAgdGhpcy5zZXRDdXJOb2RlKG5ld05vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3Tm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3IgYSBiYXNpYyBjdXJzb3Igd2Ugb25seSBoYXZlIHRoZSBhYmlsaXR5IHRvIGdvIG5leHQgYW5kIHByZXZpb3VzLCBzb1xuICAgKiBvdXQgd2lsbCBhbGxvdyB0aGUgdXNlciB0byBnZXQgdG8gdGhlIHByZXZpb3VzIG5vZGUgaW4gdGhlIHByZSBvcmRlclxuICAgKiB0cmF2ZXJzYWwuXG4gICAqIEByZXR1cm4ge0Jsb2NrbHkuQVNUTm9kZX0gVGhlIHByZXZpb3VzIG5vZGUsIG9yIG51bGwgaWYgdGhlIGN1cnJlbnRcbiAgICogICAgIG5vZGUgaXMgbm90IHNldCBvciB0aGVyZSBpcyBubyBwcmV2aW91cyB2YWx1ZS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBvdXQoKSB7XG4gICAgY29uc3QgY3VyTm9kZSA9IHRoaXMuZ2V0Q3VyTm9kZSgpO1xuICAgIGlmICghY3VyTm9kZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG5ld05vZGUgPSB0aGlzLmdldFByZXZpb3VzTm9kZV8oY3VyTm9kZSwgdGhpcy52YWxpZEluTGluZU5vZGVfKTtcblxuICAgIGlmIChuZXdOb2RlKSB7XG4gICAgICB0aGlzLnNldEN1ck5vZGUobmV3Tm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXdOb2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1lYW50IHRvIHRyYXZlcnNlIGJ5IGxpbmVzIG9mIGNvZGUuIFRoaXMgaXMgYmxvY2tzLCBzdGF0ZW1lbnQgaW5wdXRzIGFuZFxuICAgKiBuZXh0IGNvbm5lY3Rpb25zLlxuICAgKiBAcGFyYW0ge0Jsb2NrbHkuQVNUTm9kZX0gbm9kZSBUaGUgQVNUIG5vZGUgdG8gY2hlY2sgd2hldGhlciBpdCBpcyB2YWxpZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgbm9kZSBzaG91bGQgYmUgdmlzaXRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdmFsaWRMaW5lTm9kZV8obm9kZSkge1xuICAgIGlmICghbm9kZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgaXNWYWxpZCA9IGZhbHNlO1xuICAgIGNvbnN0IGxvY2F0aW9uID0gbm9kZS5nZXRMb2NhdGlvbigpO1xuICAgIGNvbnN0IHR5cGUgPSBub2RlICYmIG5vZGUuZ2V0VHlwZSgpO1xuICAgIGlmICh0eXBlID09IEJsb2NrbHkuQVNUTm9kZS50eXBlcy5QUkVWSU9VUykge1xuICAgICAgaXNWYWxpZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0eXBlID09IEJsb2NrbHkuQVNUTm9kZS50eXBlcy5JTlBVVCAmJlxuICAgICAgICBsb2NhdGlvbi50eXBlID09IEJsb2NrbHkuTkVYVF9TVEFURU1FTlQpIHtcbiAgICAgIGlzVmFsaWQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBCbG9ja2x5LkFTVE5vZGUudHlwZXMuTkVYVCkge1xuICAgICAgaXNWYWxpZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBCbG9ja2x5LkFTVE5vZGUudHlwZXMuT1VUUFVUKSB7XG4gICAgICBpZiAoIWxvY2F0aW9uLnRhcmdldENvbm5lY3Rpb24pIHtcbiAgICAgICAgaXNWYWxpZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpc1ZhbGlkO1xuICB9XG5cbiAgLyoqXG4gICAqIE1lYW50IHRvIHRyYXZlcnNlIHdpdGhpbiBhIGJsb2NrLiBUaGVzZSBhcmUgZmllbGRzIGFuZCBpbnB1dCB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7QmxvY2tseS5BU1ROb2RlfSBub2RlIFRoZSBBU1Qgbm9kZSB0byBjaGVjayB3aGV0aGVyIGl0IGlzIHZhbGlkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBub2RlIHNob3VsZCBiZSB2aXNpdGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB2YWxpZEluTGluZU5vZGVfKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IGlzVmFsaWQgPSBmYWxzZTtcbiAgICBjb25zdCBsb2NhdGlvbiA9IG5vZGUuZ2V0TG9jYXRpb24oKTtcbiAgICBjb25zdCB0eXBlID0gbm9kZSAmJiBub2RlLmdldFR5cGUoKTtcbiAgICBpZiAodHlwZSA9PT0gQmxvY2tseS5BU1ROb2RlLnR5cGVzLkZJRUxEKSB7XG4gICAgICBpc1ZhbGlkID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IEJsb2NrbHkuQVNUTm9kZS50eXBlcy5JTlBVVCAmJiBsb2NhdGlvbi50eXBlID09PSBCbG9ja2x5LklOUFVUX1ZBTFVFKSB7XG4gICAgICBpc1ZhbGlkID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gQmxvY2tseS5BU1ROb2RlLnR5cGVzLk9VVFBVVCkge1xuICAgICAgaXNWYWxpZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0eXBlID09IEJsb2NrbHkuQVNUTm9kZS50eXBlcy5TVEFDSykge1xuICAgICAgaXNWYWxpZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBpc1ZhbGlkO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/line_cursor.js\n");

/***/ })

})
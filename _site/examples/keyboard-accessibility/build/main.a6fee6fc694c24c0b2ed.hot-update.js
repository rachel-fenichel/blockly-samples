webpackHotUpdate("main",{

/***/ "./src/line_cursor.js":
/*!****************************!*\
  !*** ./src/line_cursor.js ***!
  \****************************/
/*! exports provided: LineCursor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LineCursor\", function() { return LineCursor; });\n/* harmony import */ var blockly__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly */ \"./node_modules/blockly/dist/index.js\");\n/* harmony import */ var blockly__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly__WEBPACK_IMPORTED_MODULE_0__);\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The class representing a line cursor.\n * A line cursor traverses the blocks as if they were\n * lines of code in a text editor.\n * Previous and next go up and down lines. In and out go\n * through the elements in a line.\n * @author aschmiedt@google.com (Abby Schmiedt)\n */\n\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n/**\n * Class for a line cursor.\n * This will allow the user to get to all nodes in the AST by hitting next or\n * previous.\n * @constructor\n * @extends {Blockly.BasicCursor}\n */\n\nvar LineCursor = /*#__PURE__*/function (_Blockly$BasicCursor) {\n  _inherits(LineCursor, _Blockly$BasicCursor);\n\n  var _super = _createSuper(LineCursor);\n\n  /**\n   * Constructor for a line cursor.\n   */\n  function LineCursor() {\n    _classCallCheck(this, LineCursor);\n\n    return _super.call(this);\n  }\n  /**\n   * Find the next node in the pre order traversal.\n   * @return {Blockly.ASTNode} The next node, or null if the current node is\n   *     not set or there is no next value.\n   * @override\n   */\n\n\n  _createClass(LineCursor, [{\n    key: \"next\",\n    value: function next() {\n      var curNode = this.getCurNode();\n\n      if (!curNode) {\n        return null;\n      }\n\n      var newNode = this.getNextNode_(curNode, this.validLineNode_); // Skip the input or next value if there is a connected block.\n\n      if (newNode && (newNode.getType() == blockly__WEBPACK_IMPORTED_MODULE_0__[\"ASTNode\"].types.INPUT || newNode.getType() == blockly__WEBPACK_IMPORTED_MODULE_0__[\"ASTNode\"].types.NEXT) && newNode.getLocation().targetBlock()) {\n        newNode = this.getNextNode_(newNode, this.validLineNode_);\n      }\n\n      if (newNode) {\n        this.setCurNode(newNode);\n      }\n\n      return newNode;\n    }\n    /**\n     * Find the previous node in the pre order traversal.\n     * @return {Blockly.ASTNode} The previous node, or null if the current node\n     *     is not set or there is no previous value.\n     * @override\n     */\n\n  }, {\n    key: \"prev\",\n    value: function prev() {\n      var curNode = this.getCurNode();\n\n      if (!curNode) {\n        return null;\n      }\n\n      var newNode = this.getPreviousNode_(curNode, this.validLineNode_);\n\n      if (newNode && (newNode.getType() == blockly__WEBPACK_IMPORTED_MODULE_0__[\"ASTNode\"].types.INPUT || newNode.getType() == blockly__WEBPACK_IMPORTED_MODULE_0__[\"ASTNode\"].types.NEXT) && newNode.getLocation().targetBlock()) {\n        newNode = this.getPreviousNode_(newNode, this.validLineNode_);\n      }\n\n      if (newNode) {\n        this.setCurNode(newNode);\n      }\n\n      return newNode;\n    }\n    /**\n     * For a basic cursor we only have the ability to go next and previous, so\n     * in will also allow the user to get to the next node in the pre order\n     * traversal.\n     * @return {Blockly.ASTNode} The next node, or null if the current node is\n     *     not set or there is no next value.\n     * @override\n     */\n\n  }, {\n    key: \"in\",\n    value: function _in() {\n      var curNode = this.getCurNode();\n\n      if (!curNode) {\n        return null;\n      }\n\n      var newNode = this.getNextNode_(curNode, this.validInLineNode_);\n\n      if (newNode) {\n        this.setCurNode(newNode);\n      }\n\n      return newNode;\n    }\n    /**\n     * For a basic cursor we only have the ability to go next and previous, so\n     * out will allow the user to get to the previous node in the pre order traversal.\n     * @return {Blockly.ASTNode} The previous node, or null if the current node is\n     *     not set or there is no previous value.\n     * @override\n     */\n\n  }, {\n    key: \"out\",\n    value: function out() {\n      var curNode = this.getCurNode();\n\n      if (!curNode) {\n        return null;\n      }\n\n      var newNode = this.getPreviousNode_(curNode, this.validInLineNode_);\n\n      if (newNode) {\n        this.setCurNode(newNode);\n      }\n\n      return newNode;\n    }\n    /**\n     * Meant to traverse by lines of code. This is blocks, statement inputs and\n     * next connections.\n     * @param {Blockly.ASTNode} node The AST node to check whether it is valid.\n     * @return {boolean} True if the node should be visited, false otherwise.\n     * @private\n     */\n\n  }, {\n    key: \"validLineNode_\",\n    value: function validLineNode_(node) {\n      if (!node) {\n        return false;\n      }\n\n      var isValid = false;\n      var location = node.getLocation();\n      var type = node && node.getType();\n\n      if (type == blockly__WEBPACK_IMPORTED_MODULE_0__[\"ASTNode\"].types.PREVIOUS) {\n        isValid = true;\n      } else if (type == blockly__WEBPACK_IMPORTED_MODULE_0__[\"ASTNode\"].types.INPUT && location.type == blockly__WEBPACK_IMPORTED_MODULE_0__[\"NEXT_STATEMENT\"]) {\n        isValid = true;\n      } else if (type == blockly__WEBPACK_IMPORTED_MODULE_0__[\"ASTNode\"].types.NEXT) {\n        isValid = true;\n      } else if (type === blockly__WEBPACK_IMPORTED_MODULE_0__[\"ASTNode\"].types.OUTPUT) {\n        if (!location.targetConnection) {\n          isValid = true;\n        }\n      }\n\n      return isValid;\n    }\n    /**\n     * Meant to traverse within a block. These are fields and input values.\n     * @param {Blockly.ASTNode} node The AST node to check whether it is valid.\n     * @return {boolean} True if the node should be visited, false otherwise.\n     * @private\n     */\n\n  }, {\n    key: \"validInLineNode_\",\n    value: function validInLineNode_(node) {\n      if (!node) {\n        return false;\n      }\n\n      var isValid = false;\n      var location = node.getLocation();\n      var type = node && node.getType();\n\n      if (type === blockly__WEBPACK_IMPORTED_MODULE_0__[\"ASTNode\"].types.FIELD) {\n        isValid = true;\n      } else if (type === blockly__WEBPACK_IMPORTED_MODULE_0__[\"ASTNode\"].types.INPUT && location.type === blockly__WEBPACK_IMPORTED_MODULE_0__[\"INPUT_VALUE\"]) {\n        isValid = true;\n      } else if (type == blockly__WEBPACK_IMPORTED_MODULE_0__[\"ASTNode\"].types.OUTPUT) {\n        isValid = true;\n      } else if (type == blockly__WEBPACK_IMPORTED_MODULE_0__[\"ASTNode\"].types.STACK) {\n        isValid = true;\n      }\n\n      return isValid;\n    }\n  }]);\n\n  return LineCursor;\n}(blockly__WEBPACK_IMPORTED_MODULE_0__[\"BasicCursor\"]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGluZV9jdXJzb3IuanM/MzczNSJdLCJuYW1lcyI6WyJMaW5lQ3Vyc29yIiwiY3VyTm9kZSIsImdldEN1ck5vZGUiLCJuZXdOb2RlIiwiZ2V0TmV4dE5vZGVfIiwidmFsaWRMaW5lTm9kZV8iLCJnZXRUeXBlIiwiQmxvY2tseSIsInR5cGVzIiwiSU5QVVQiLCJORVhUIiwiZ2V0TG9jYXRpb24iLCJ0YXJnZXRCbG9jayIsInNldEN1ck5vZGUiLCJnZXRQcmV2aW91c05vZGVfIiwidmFsaWRJbkxpbmVOb2RlXyIsIm5vZGUiLCJpc1ZhbGlkIiwibG9jYXRpb24iLCJ0eXBlIiwiUFJFVklPVVMiLCJPVVRQVVQiLCJ0YXJnZXRDb25uZWN0aW9uIiwiRklFTEQiLCJTVEFDSyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRWI7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDTyxJQUFNQSxVQUFiO0FBQUE7O0FBQUE7O0FBQ0U7QUFDRjtBQUNBO0FBQ0Usd0JBQWM7QUFBQTs7QUFBQTtBQUViO0FBQ0Q7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFaQTtBQUFBO0FBQUEsMkJBYVM7QUFDTCxVQUFNQyxPQUFPLEdBQUcsS0FBS0MsVUFBTCxFQUFoQjs7QUFDQSxVQUFJLENBQUNELE9BQUwsRUFBYztBQUNaLGVBQU8sSUFBUDtBQUNEOztBQUNELFVBQUlFLE9BQU8sR0FBRyxLQUFLQyxZQUFMLENBQWtCSCxPQUFsQixFQUEyQixLQUFLSSxjQUFoQyxDQUFkLENBTEssQ0FPTDs7QUFDQSxVQUFJRixPQUFPLEtBQUtBLE9BQU8sQ0FBQ0csT0FBUixNQUFxQkMsK0NBQUEsQ0FBZ0JDLEtBQWhCLENBQXNCQyxLQUEzQyxJQUNa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LEtBQWhCLENBQXNCZ0IsS0FBbEMsRUFBeUM7QUFDOUNQLGVBQU8sR0FBRyxJQUFWO0FBQ0Q7O0FBQ0QsYUFBT0EsT0FBUDtBQUNEO0FBdkpIOztBQUFBO0FBQUEsRUFBZ0NWLG1EQUFoQyIsImZpbGUiOiIuL3NyYy9saW5lX2N1cnNvci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRoZSBjbGFzcyByZXByZXNlbnRpbmcgYSBsaW5lIGN1cnNvci5cbiAqIEEgbGluZSBjdXJzb3IgdHJhdmVyc2VzIHRoZSBibG9ja3MgYXMgaWYgdGhleSB3ZXJlXG4gKiBsaW5lcyBvZiBjb2RlIGluIGEgdGV4dCBlZGl0b3IuXG4gKiBQcmV2aW91cyBhbmQgbmV4dCBnbyB1cCBhbmQgZG93biBsaW5lcy4gSW4gYW5kIG91dCBnb1xuICogdGhyb3VnaCB0aGUgZWxlbWVudHMgaW4gYSBsaW5lLlxuICogQGF1dGhvciBhc2NobWllZHRAZ29vZ2xlLmNvbSAoQWJieSBTY2htaWVkdClcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgKiBhcyBCbG9ja2x5IGZyb20gJ2Jsb2NrbHknO1xuXG4vKipcbiAqIENsYXNzIGZvciBhIGxpbmUgY3Vyc29yLlxuICogVGhpcyB3aWxsIGFsbG93IHRoZSB1c2VyIHRvIGdldCB0byBhbGwgbm9kZXMgaW4gdGhlIEFTVCBieSBoaXR0aW5nIG5leHQgb3JcbiAqIHByZXZpb3VzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7QmxvY2tseS5CYXNpY0N1cnNvcn1cbiAqL1xuZXhwb3J0IGNsYXNzIExpbmVDdXJzb3IgZXh0ZW5kcyBCbG9ja2x5LkJhc2ljQ3Vyc29yIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yIGZvciBhIGxpbmUgY3Vyc29yLlxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuICAvKipcbiAgICogRmluZCB0aGUgbmV4dCBub2RlIGluIHRoZSBwcmUgb3JkZXIgdHJhdmVyc2FsLlxuICAgKiBAcmV0dXJuIHtCbG9ja2x5LkFTVE5vZGV9IFRoZSBuZXh0IG5vZGUsIG9yIG51bGwgaWYgdGhlIGN1cnJlbnQgbm9kZSBpc1xuICAgKiAgICAgbm90IHNldCBvciB0aGVyZSBpcyBubyBuZXh0IHZhbHVlLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIG5leHQoKSB7XG4gICAgY29uc3QgY3VyTm9kZSA9IHRoaXMuZ2V0Q3VyTm9kZSgpO1xuICAgIGlmICghY3VyTm9kZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCBuZXdOb2RlID0gdGhpcy5nZXROZXh0Tm9kZV8oY3VyTm9kZSwgdGhpcy52YWxpZExpbmVOb2RlXyk7XG5cbiAgICAvLyBTa2lwIHRoZSBpbnB1dCBvciBuZXh0IHZhbHVlIGlmIHRoZXJlIGlzIGEgY29ubmVjdGVkIGJsb2NrLlxuICAgIGlmIChuZXdOb2RlICYmIChuZXdOb2RlLmdldFR5cGUoKSA9PSBCbG9ja2x5LkFTVE5vZGUudHlwZXMuSU5QVVQgfHxcbiAgICAgICAgbmV3Tm9kZS5nZXRUeXBlKCkgPT0gQmxvY2tseS5BU1ROb2RlLnR5cGVzLk5FWFQpICYmXG4gICAgICAgIG5ld05vZGUuZ2V0TG9jYXRpb24oKS50YXJnZXRCbG9jaygpKSB7XG4gICAgICBuZXdOb2RlID0gdGhpcy5nZXROZXh0Tm9kZV8obmV3Tm9kZSwgdGhpcy52YWxpZExpbmVOb2RlXyk7XG4gICAgfVxuICAgIGlmIChuZXdOb2RlKSB7XG4gICAgICB0aGlzLnNldEN1ck5vZGUobmV3Tm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXdOb2RlO1xuICB9XG5cblxuICAvKipcbiAgICogRmluZCB0aGUgcHJldmlvdXMgbm9kZSBpbiB0aGUgcHJlIG9yZGVyIHRyYXZlcnNhbC5cbiAgICogQHJldHVybiB7QmxvY2tseS5BU1ROb2RlfSBUaGUgcHJldmlvdXMgbm9kZSwgb3IgbnVsbCBpZiB0aGUgY3VycmVudCBub2RlXG4gICAqICAgICBpcyBub3Qgc2V0IG9yIHRoZXJlIGlzIG5vIHByZXZpb3VzIHZhbHVlLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHByZXYoKSB7XG4gICAgY29uc3QgY3VyTm9kZSA9IHRoaXMuZ2V0Q3VyTm9kZSgpO1xuICAgIGlmICghY3VyTm9kZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCBuZXdOb2RlID0gdGhpcy5nZXRQcmV2aW91c05vZGVfKGN1ck5vZGUsIHRoaXMudmFsaWRMaW5lTm9kZV8pO1xuXG4gICAgaWYgKG5ld05vZGUgJiYgKG5ld05vZGUuZ2V0VHlwZSgpID09IEJsb2NrbHkuQVNUTm9kZS50eXBlcy5JTlBVVCB8fFxuICAgICAgbmV3Tm9kZS5nZXRUeXBlKCkgPT0gQmxvY2tseS5BU1ROb2RlLnR5cGVzLk5FWFQpICYmXG4gICAgICBuZXdOb2RlLmdldExvY2F0aW9uKCkudGFyZ2V0QmxvY2soKSkge1xuICAgICAgbmV3Tm9kZSA9IHRoaXMuZ2V0UHJldmlvdXNOb2RlXyhuZXdOb2RlLCB0aGlzLnZhbGlkTGluZU5vZGVfKTtcbiAgICB9XG5cbiAgICBpZiAobmV3Tm9kZSkge1xuICAgICAgdGhpcy5zZXRDdXJOb2RlKG5ld05vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3Tm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3IgYSBiYXNpYyBjdXJzb3Igd2Ugb25seSBoYXZlIHRoZSBhYmlsaXR5IHRvIGdvIG5leHQgYW5kIHByZXZpb3VzLCBzb1xuICAgKiBpbiB3aWxsIGFsc28gYWxsb3cgdGhlIHVzZXIgdG8gZ2V0IHRvIHRoZSBuZXh0IG5vZGUgaW4gdGhlIHByZSBvcmRlclxuICAgKiB0cmF2ZXJzYWwuXG4gICAqIEByZXR1cm4ge0Jsb2NrbHkuQVNUTm9kZX0gVGhlIG5leHQgbm9kZSwgb3IgbnVsbCBpZiB0aGUgY3VycmVudCBub2RlIGlzXG4gICAqICAgICBub3Qgc2V0IG9yIHRoZXJlIGlzIG5vIG5leHQgdmFsdWUuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgaW4oKSB7XG4gICAgY29uc3QgY3VyTm9kZSA9IHRoaXMuZ2V0Q3VyTm9kZSgpO1xuICAgIGlmICghY3VyTm9kZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG5ld05vZGUgPSB0aGlzLmdldE5leHROb2RlXyhjdXJOb2RlLCB0aGlzLnZhbGlkSW5MaW5lTm9kZV8pO1xuXG4gICAgaWYgKG5ld05vZGUpIHtcbiAgICAgIHRoaXMuc2V0Q3VyTm9kZShuZXdOb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld05vZGU7XG4gIH1cblxuICAvKipcbiAgICogRm9yIGEgYmFzaWMgY3Vyc29yIHdlIG9ubHkgaGF2ZSB0aGUgYWJpbGl0eSB0byBnbyBuZXh0IGFuZCBwcmV2aW91cywgc29cbiAgICogb3V0IHdpbGwgYWxsb3cgdGhlIHVzZXIgdG8gZ2V0IHRvIHRoZSBwcmV2aW91cyBub2RlIGluIHRoZSBwcmUgb3JkZXIgdHJhdmVyc2FsLlxuICAgKiBAcmV0dXJuIHtCbG9ja2x5LkFTVE5vZGV9IFRoZSBwcmV2aW91cyBub2RlLCBvciBudWxsIGlmIHRoZSBjdXJyZW50IG5vZGUgaXNcbiAgICogICAgIG5vdCBzZXQgb3IgdGhlcmUgaXMgbm8gcHJldmlvdXMgdmFsdWUuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgb3V0KCkge1xuICAgIGNvbnN0IGN1ck5vZGUgPSB0aGlzLmdldEN1ck5vZGUoKTtcbiAgICBpZiAoIWN1ck5vZGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBuZXdOb2RlID0gdGhpcy5nZXRQcmV2aW91c05vZGVfKGN1ck5vZGUsIHRoaXMudmFsaWRJbkxpbmVOb2RlXyk7XG5cbiAgICBpZiAobmV3Tm9kZSkge1xuICAgICAgdGhpcy5zZXRDdXJOb2RlKG5ld05vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3Tm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZWFudCB0byB0cmF2ZXJzZSBieSBsaW5lcyBvZiBjb2RlLiBUaGlzIGlzIGJsb2Nrcywgc3RhdGVtZW50IGlucHV0cyBhbmRcbiAgICogbmV4dCBjb25uZWN0aW9ucy5cbiAgICogQHBhcmFtIHtCbG9ja2x5LkFTVE5vZGV9IG5vZGUgVGhlIEFTVCBub2RlIHRvIGNoZWNrIHdoZXRoZXIgaXQgaXMgdmFsaWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIG5vZGUgc2hvdWxkIGJlIHZpc2l0ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHZhbGlkTGluZU5vZGVfKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IGlzVmFsaWQgPSBmYWxzZTtcbiAgICBjb25zdCBsb2NhdGlvbiA9IG5vZGUuZ2V0TG9jYXRpb24oKTtcbiAgICBjb25zdCB0eXBlID0gbm9kZSAmJiBub2RlLmdldFR5cGUoKTtcbiAgICBpZiAodHlwZSA9PSBCbG9ja2x5LkFTVE5vZGUudHlwZXMuUFJFVklPVVMpIHtcbiAgICAgIGlzVmFsaWQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBCbG9ja2x5LkFTVE5vZGUudHlwZXMuSU5QVVQgJiZcbiAgICAgICAgbG9jYXRpb24udHlwZSA9PSBCbG9ja2x5Lk5FWFRfU1RBVEVNRU5UKSB7XG4gICAgICBpc1ZhbGlkID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gQmxvY2tseS5BU1ROb2RlLnR5cGVzLk5FWFQpIHtcbiAgICAgIGlzVmFsaWQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gQmxvY2tseS5BU1ROb2RlLnR5cGVzLk9VVFBVVCkge1xuICAgICAgaWYgKCFsb2NhdGlvbi50YXJnZXRDb25uZWN0aW9uKSB7XG4gICAgICAgIGlzVmFsaWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaXNWYWxpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZWFudCB0byB0cmF2ZXJzZSB3aXRoaW4gYSBibG9jay4gVGhlc2UgYXJlIGZpZWxkcyBhbmQgaW5wdXQgdmFsdWVzLlxuICAgKiBAcGFyYW0ge0Jsb2NrbHkuQVNUTm9kZX0gbm9kZSBUaGUgQVNUIG5vZGUgdG8gY2hlY2sgd2hldGhlciBpdCBpcyB2YWxpZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgbm9kZSBzaG91bGQgYmUgdmlzaXRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdmFsaWRJbkxpbmVOb2RlXyhub2RlKSB7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBpc1ZhbGlkID0gZmFsc2U7XG4gICAgY29uc3QgbG9jYXRpb24gPSBub2RlLmdldExvY2F0aW9uKCk7XG4gICAgY29uc3QgdHlwZSA9IG5vZGUgJiYgbm9kZS5nZXRUeXBlKCk7XG4gICAgaWYgKHR5cGUgPT09IEJsb2NrbHkuQVNUTm9kZS50eXBlcy5GSUVMRCkge1xuICAgICAgaXNWYWxpZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBCbG9ja2x5LkFTVE5vZGUudHlwZXMuSU5QVVQgJiYgbG9jYXRpb24udHlwZSA9PT0gQmxvY2tseS5JTlBVVF9WQUxVRSkge1xuICAgICAgaXNWYWxpZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0eXBlID09IEJsb2NrbHkuQVNUTm9kZS50eXBlcy5PVVRQVVQpIHtcbiAgICAgIGlzVmFsaWQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBCbG9ja2x5LkFTVE5vZGUudHlwZXMuU1RBQ0spIHtcbiAgICAgIGlzVmFsaWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gaXNWYWxpZDtcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/line_cursor.js\n");

/***/ })

})
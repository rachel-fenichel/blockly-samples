webpackHotUpdate("main",{

/***/ "./src/speaker.js":
/*!************************!*\
  !*** ./src/speaker.js ***!
  \************************/
/*! exports provided: Speaker, speaker */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Speaker\", function() { return Speaker; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"speaker\", function() { return speaker; });\n/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ \"./node_modules/blockly/dist/core-browser.js\");\n/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Speaker used for speaking out text.\n */\n\n/**\n * Convenience methods for speaking out text.\n * More information on speakers can be found here:\n * https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesis.\n */\n\nvar Speaker = /*#__PURE__*/function () {\n  /**\n   * Constructor for a speaker.\n   * @param {SpeakerMessages=} optMessages Optional messages for the speaker.\n   */\n  function Speaker(optMessages) {\n    _classCallCheck(this, Speaker);\n\n    var messages = {\n      'MAIN_WS': 'On the main workspace',\n      'STACK': 'To go to the last block in the previous group of blocks, press' + 'previous. To go to the first block in the stack hit next.',\n      'PREVIOUS': 'You are on a connection before, ',\n      'NEXT': 'On a connection after, ',\n      'OUTPUT': 'On an output connection. ',\n      'CONNECTION': 'At a connection point.',\n      'BLOCK': 'On a block of type',\n      'CLICKABLE_FIELD': 'To interact with the field hit enter.',\n      'EMPTY_TOKEN': 'blank',\n      'MARK_CONNECTION': 'To mark the block press enter. ',\n      'EXIT_EDIT_MODE': 'To exit edit mode hit escape. '\n    };\n    blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.utils.object.mixin(messages, optMessages);\n    this.setLocale(messages);\n    this.noOverrides = false;\n  }\n  /**\n   * The messages to be read out by a screen reader.\n   * @typedef {{\n   *     MAIN_WS: string,\n   *     STACK: string,\n   *     PREVIOUS: string,\n   *     NEXT: string,\n   *     OUTPUT: string,\n   *     CONNECTION: string,\n   *     BLOCK: string,\n   *     EMPTY_TOKEN: string,\n   *     MARK_CONNECTION: string,\n   * }} SpeakerMessages\n   */\n\n  /**\n   * Set the messages for the speaker.\n   * @param {!SpeakerMessages} messages The messages needed to create a speaker.\n   */\n\n\n  _createClass(Speaker, [{\n    key: \"setLocale\",\n    value: function setLocale(messages) {\n      Object.keys(messages).forEach(function (k) {\n        blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.Msg[k] = messages[k];\n      });\n    }\n    /**\n     * Speaks out the text that was given to it.\n     * @param {string} text The text to speak out.\n     * @param {boolean=} shouldCancel True to stop the current utterance, false to\n     *     wait until the current utterance is done before speaking.\n     * @param {function=} onEnd The function to run after the text has been\n     *     spoken.\n     * @param {function=} onStart The function run when the text has begun to\n     *     be spoken.\n     * @public\n     */\n\n  }, {\n    key: \"speak\",\n    value: function speak(text, shouldCancel, onEnd, onStart) {\n      var audio = new SpeechSynthesisUtterance(text);\n\n      if (shouldCancel && !this.noOverrides && window.speechSynthesis.speaking) {\n        window.speechSynthesis.cancel();\n      }\n\n      if (onEnd) {\n        audio.onend = onEnd;\n      }\n\n      if (onStart) {\n        audio.onstart = onStart;\n      }\n\n      window.speechSynthesis.speak(audio);\n    }\n    /**\n     * Clears out the queue of text to speak.\n     * @public\n     */\n\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      window.speechSynthesis.cancel();\n    }\n    /**\n     * Pauses speaking.\n     */\n\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      window.speechSynthesis.pause();\n    }\n    /**\n     * Resumes speaking.\n     */\n\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      window.speechSynthesis.resume();\n    }\n    /**\n     * Speaks out text if the event is of type marker or cursor move.\n     * @param {!Blockly.Events} event The event to speak out.\n     */\n\n  }, {\n    key: \"nodeToSpeech\",\n    value: function nodeToSpeech(event) {\n      // TODO: Update this if we link to the current version of blockly.\n      if (event.type === blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.Events.MARKER_MOVE) {\n        var nodeText = this.nodeToText_(event.newNode, event.oldNode, !event.isCursor);\n\n        if (!event.isCursor) {\n          nodeText = \"You have marked a location. To find a new block to connect\\n        to this location hit T. ! . To insert a block on the workspace,\\n        find the location of the block and hit I. \";\n        }\n\n        this.speak(nodeText, true);\n      }\n    }\n    /**\n     * Speaks out the text for a modal.\n     * @param {Element} modal The modal to collect the text to read out.\n     * @public\n     */\n\n  }, {\n    key: \"modalToText\",\n    value: function modalToText(modal) {\n      var header = modal.querySelector('header');\n      var headerText = header.textContent.trim();\n\n      if (headerText !== '') {\n        this.speak(headerText);\n      }\n\n      this.addButtonListeners_(header.querySelectorAll('button'));\n      var mainText = modal.querySelector('main').textContent.trim();\n\n      if (mainText !== '') {\n        this.speak(mainText);\n      }\n\n      var footerBtns = modal.querySelector('footer').querySelectorAll('button');\n      this.addButtonListeners_(footerBtns);\n    }\n    /**\n     * Adds listeners for when the button is focused.\n     * @param {!NodeList} btns The buttons to add listeners to.\n     * @private\n     */\n\n  }, {\n    key: \"addButtonListeners_\",\n    value: function addButtonListeners_(btns) {\n      var _this = this;\n\n      var _iterator = _createForOfIteratorHelper(btns),\n          _step;\n\n      try {\n        var _loop = function _loop() {\n          var btn = _step.value;\n          btn.addEventListener('focus', function () {\n            _this.buttonToSpeech_(btns, btn, true);\n          });\n\n          if (document.activeElement === btn) {\n            _this.buttonToSpeech_(btns, btn, false);\n          }\n        };\n\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    /**\n     * Speaks out information about a button.\n     * @param {NodeList} btns The list of buttons on the modal.\n     * @param {Element} btn The button.\n     * @param {boolean} shouldCancel True if this should cancel the previous\n     *     utterance.\n     * @private\n     */\n\n  }, {\n    key: \"buttonToSpeech_\",\n    value: function buttonToSpeech_(btns, btn, shouldCancel) {\n      this.speak('Hit enter to ', shouldCancel);\n\n      if (btn.textContent === '') {\n        this.speak(btn.getAttribute('aria-label'));\n      } else {\n        this.speak(btn.textContent);\n      }\n\n      if (btns.length > 0) {\n        this.speak('Hit tab to go to your next option');\n      }\n    }\n    /**\n     * Speaks out an audio representation of the given node.\n     * @param {Blockly.ASTNode} node The node to speak out.\n     * @param {Blockly.ASTNode} oldNode The previous node to speak out.\n     * @param {boolean} isMarker True to get the text for a marker,\n     *     false otherwise.\n     * @return {string} The text representation of the node.\n     * @public\n     */\n\n  }, {\n    key: \"nodeToText_\",\n    value: function nodeToText_(node, oldNode, isMarker) {\n      var finalText = '';\n\n      switch (node.getType()) {\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.FIELD:\n          finalText = this.fieldNodeToText_(node);\n          break;\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.BLOCK:\n          finalText = this.blockNodeToText_(node);\n          break;\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.INPUT:\n          finalText = this.inputNodeToText_(node, isMarker);\n          break;\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.OUTPUT:\n          finalText = this.outputNodeToText_(node, isMarker);\n          break;\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.NEXT:\n          finalText = this.nextNodeToText_(node, isMarker);\n          break;\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.PREVIOUS:\n          finalText = this.previousNodeToText_(node, isMarker);\n          break;\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.STACK:\n          finalText = this.stackNodeToText_(node, oldNode);\n          break;\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.WORKSPACE:\n          finalText = this.workspaceNodeToText_(node);\n          break;\n\n        default:\n          return node.toString();\n      }\n\n      finalText += this.getNextOptions_(node, oldNode, isMarker);\n      return finalText;\n    }\n    /**\n     * Gets text explaining the next options available for a user.\n     * @param {!Blockly.ASTNode} node The current node.\n     * @param {!Blockly.ASTNode} oldNode The previous node.\n     * @param {boolean} isMarker True if the marker was moved.\n     * @return {string} Text explaining next options for the field.\n     * @private\n     */\n\n  }, {\n    key: \"getNextOptions_\",\n    value: function getNextOptions_(node, oldNode, isMarker) {\n      switch (node.getType()) {\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.FIELD:\n          return this.getFieldOptions_(node);\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.BLOCK:\n          return this.getBlockOptions_(node);\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.INPUT:\n          return this.getConnectionOptions_(node, isMarker);\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.OUTPUT:\n          return this.getConnectionOptions_(node, isMarker);\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.NEXT:\n          return this.getConnectionOptions_(node, isMarker);\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.PREVIOUS:\n          return this.getConnectionOptions_(node, isMarker);\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.STACK:\n          return this.getStackOptions_(node);\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.WORKSPACE:\n          return '';\n\n        default:\n          return node.toString();\n      }\n    }\n    /**\n     * Gets the next options for when a user is on a field.\n     * This is to open the field or to change locations.\n     * @param {!Blockly.ASTNode} node The field node.\n     * @return {string} The text explaining the next options when a user is on a\n     *     field.\n     * @private\n     */\n\n  }, {\n    key: \"getFieldOptions_\",\n    value: function getFieldOptions_(node) {\n      var field = node.getLocation();\n\n      if (field.isClickable()) {\n        return \"To interact with the field hit enter. Use the next or previous\\n      keys to change locations. \";\n      } else {\n        return 'Use the next or previous keys to change locations. ';\n      }\n    }\n    /**\n     * Gets the next options for when a user is on a block.\n     * @return {string} The text explaining the next options for a block.\n     * @private\n     */\n\n  }, {\n    key: \"getBlockOptions_\",\n    value: function getBlockOptions_() {\n      return \"Use the next or previous keys to change locations. \";\n    }\n    /**\n     * Gets the text for the connection point.\n     * @param {!Blockly.ASTNode} node The connection node.\n     * @param {boolean} isMarker True if the marker was moved.\n     * @return {string} The text explaining the next options when a user is on a\n     *     connection.\n     * @private\n     */\n\n  }, {\n    key: \"getConnectionOptions_\",\n    value: function getConnectionOptions_(node, isMarker) {\n      var markerText = \". To mark this location, hit enter.\\n    To change locations use the next or previous keys\";\n      var finalText = '';\n\n      if (!isMarker) {\n        finalText += \"\".concat(markerText);\n      }\n\n      return finalText;\n    }\n    /**\n     * Gets the options for a user on a  stack of blocks.\n     * @param {Blockly.ASTNode} node The stack node.\n     * @return {string} The text explaining the next options when a user is on a\n     *     stack of blocks.\n     * @private\n     */\n\n  }, {\n    key: \"getStackOptions_\",\n    value: function getStackOptions_(node) {\n      var finalText = '';\n\n      if (node.prev()) {\n        finalText += \"To go to the last block in the previous group of blocks,\\n      press previous.\";\n      }\n\n      finalText += \" To go to the first block in the stack hit next.\";\n      return finalText;\n    }\n    /**\n     * Get the text for the source block of the node.\n     * @param {!Blockly.BlockSvg} srcBlock The block to get the text for.\n     * @param {string=} opt_emptyToken The optional empty token.\n     * @return {string} The text describing the source block of the node.\n     * @private\n     */\n\n  }, {\n    key: \"getBlockText_\",\n    value: function getBlockText_(srcBlock, opt_emptyToken) {\n      var emptyToken = opt_emptyToken || blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.Msg['EMPTY_TOKEN'];\n\n      if (srcBlock) {\n        if (srcBlock.statementInputCount > 0) {\n          emptyToken = ' do blank ';\n        }\n\n        return srcBlock.toString(null, emptyToken);\n      } else {\n        return '';\n      }\n    }\n    /**\n     * Creates text for a feild.\n     * @param {!Blockly.ASTNode} node The node to create text for.\n     * @return {string} The text for the screen reader to read out.\n     * @protected\n     */\n\n  }, {\n    key: \"fieldNodeToText_\",\n    value: function fieldNodeToText_(node) {\n      var field = node.getLocation();\n      return field.getText() + '. ';\n    }\n    /**\n     * Creates text for a feild.\n     * @param {!Blockly.ASTNode} node The node to create text for.\n     * @return {string} The text for the screen reader to read out.\n     * @protected\n     */\n\n  }, {\n    key: \"blockNodeToText_\",\n    value: function blockNodeToText_(node) {\n      var block =\n      /** @type{Blockly.BlockSvg} */\n      node.getLocation();\n      var blockText = this.getBlockText_(block);\n      var finalText = '';\n\n      if (block.getSurroundParent()) {\n        var parentBlockText = this.getBlockText_(block.getSurroundParent());\n        finalText += \"You are inside of block \".concat(parentBlockText, \". . \");\n      }\n\n      finalText += \"You are on , \".concat(blockText, \". . \");\n      return finalText;\n    }\n    /**\n     * Creates text for an input.\n     * @param {!Blockly.ASTNode} node The node to create text for.\n     * @param {boolean} isMarker True if the marker was moved.\n     * @return {string} The text for the screen reader to read out.\n     * @protected\n     */\n\n  }, {\n    key: \"inputNodeToText_\",\n    value: function inputNodeToText_(node, isMarker) {\n      var inputConnection =\n      /** @type{Blockly.Input} */\n      node.getLocation();\n      var connectionText = \"You are on a connection\";\n      var finalText = '';\n\n      if (inputConnection.type === blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.NEXT_STATEMENT) {\n        var blockText = this.getBlockText_(node.getSourceBlock());\n        finalText = \"Inside \".concat(blockText, \". \").concat(connectionText, \". \");\n      } else if (inputConnection.type === blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.INPUT_VALUE) {\n        var _blockText = this.getBlockText_(node.getSourceBlock(), ' ');\n\n        finalText = \"\".concat(connectionText, \" after \").concat(_blockText);\n      }\n\n      return finalText;\n    }\n    /**\n     * Creates text for a output connection.\n     * @param {!Blockly.ASTNode} node The node to create text for.\n     * @return {string} The text for the screen reader to read out.\n     * @protected\n     */\n\n  }, {\n    key: \"outputNodeToText_\",\n    value: function outputNodeToText_(node) {\n      var blockText = this.getBlockText_(node.getSourceBlock());\n      return \"You are on a connection for block, \".concat(blockText);\n    }\n    /**\n     * Creates text for a next connection.\n     * @param {!Blockly.ASTNode} node The node to create text for.\n     * @param {boolean} isMarker True to get the text for a marker,\n     *     false otherwise.\n     * @return {string} The text for the screen reader to read out.\n     * @protected\n     */\n\n  }, {\n    key: \"nextNodeToText_\",\n    value: function nextNodeToText_(node, isMarker) {\n      var block = node.getSourceBlock();\n      var blockText = this.getBlockText_(node.getSourceBlock());\n      var finalText = '';\n\n      if (block.getSurroundParent()) {\n        var parentBlockText = this.getBlockText_(block.getSurroundParent());\n        finalText += \"You are inside of block \".concat(parentBlockText, \". . \");\n      }\n\n      finalText += \"\".concat(blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.Msg['NEXT'], \" \").concat(blockText);\n      return finalText;\n    }\n    /**\n     * Creates text for a previous connection.\n     * @param {!Blockly.ASTNode} node The node to create text for.\n     * @param {boolean} isMarker True to get the text for a marker,\n     *     false otherwise.\n     * @return {string} The text for the screen reader to read out.\n     * @protected\n     */\n\n  }, {\n    key: \"previousNodeToText_\",\n    value: function previousNodeToText_(node, isMarker) {\n      var block = node.getSourceBlock();\n      var blockText = this.getBlockText_(block);\n      var finalText = '';\n\n      if (block.getSurroundParent()) {\n        var parentBlockText = this.getBlockText_(block.getSurroundParent());\n        finalText += \"You are inside of block \".concat(parentBlockText, \". . \");\n      }\n\n      finalText += \"\".concat(blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.Msg['PREVIOUS'], \" \").concat(blockText);\n      return finalText;\n    }\n    /**\n     * Creates text for a stack of blocks.\n     * @param {!Blockly.ASTNode} node The node to create text for.\n     * @param {!Blockly.ASTNode} oldNode The previous node.\n     * @return {string} The text for the screen reader to read out.\n     * @protected\n     */\n\n  }, {\n    key: \"stackNodeToText_\",\n    value: function stackNodeToText_(node, oldNode) {\n      var srcBlock = node.getSourceBlock();\n      var newNodeTopBlock = srcBlock.getTopStackBlock();\n      var oldNodeTopBlock = null;\n\n      if (oldNode && oldNode.getSourceBlock()) {\n        oldNodeTopBlock = oldNode.getSourceBlock().getTopStackBlock();\n      }\n\n      var finalText = '';\n\n      if (srcBlock && srcBlock.workspace.isFlyout) {\n        finalText = this.getBlockText_(node.getSourceBlock());\n        finalText += \" . . To add this block to the workspace press Enter. .\\n      To go to the next block hit next. . To go back to the workspace\\n      hit escape. \";\n      } else if (srcBlock) {\n        if (oldNodeTopBlock !== newNodeTopBlock) {\n          finalText += \"You are on a new group of blocks. \";\n        } else {\n          finalText += \"You are on a group of blocks. \";\n        }\n      }\n\n      return finalText;\n    }\n    /**\n     * Creates text for a workspace.\n     * @param {!Blockly.ASTNode} node The node to create text for.\n     * @return {string} The text for the screen reader to read out.\n     * @protected\n     */\n\n  }, {\n    key: \"workspaceNodeToText_\",\n    value: function workspaceNodeToText_(node) {\n      var workspace =\n      /** @type{Blockly.WorkspaceSvg} */\n      node.getLocation(); // TODO: All text should be added to Blockly.Msg to allow for translation.\n\n      var text = null;\n\n      if (workspace.isFlyout) {\n        text = 'In the flyout, please select a block';\n      } else if (workspace.isMutator) {\n        text = 'In the mutator workspace, use this workspace to change a block';\n      } else {\n        text = blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.Msg['MAIN_WS'];\n      }\n\n      return text;\n    }\n  }]);\n\n  return Speaker;\n}();\nvar speaker = new Speaker();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3BlYWtlci5qcz9jZDc3Il0sIm5hbWVzIjpbIlNwZWFrZXIiLCJvcHRNZXNzYWdlcyIsIm1lc3NhZ2VzIiwiQmxvY2tseSIsInV0aWxzIiwib2JqZWN0IiwibWl4aW4iLCJzZXRMb2NhbGUiLCJub092ZXJyaWRlcyIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwiayIsIk1zZyIsInRleHQiLCJzaG91bGRDYW5jZWwiLCJvbkVuZCIsIm9uU3RhcnQiLCJhdWRpbyIsIlNwZWVjaFN5bnRoZXNpc1V0dGVyYW5jZSIsIndpbmRvdyIsInNwZWVjaFN5bnRoZXNpcyIsInNwZWFraW5nIiwiY2FuY2VsIiwib25lbmQiLCJvbnN0YXJ0Iiwic3BlYWsiLCJwYXVzZSIsInJlc3VtZSIsImV2ZW50IiwidHlwZSIsIkV2ZW50cyIsIk1BUktFUl9NT1ZFIiwibm9kZVRleHQiLCJub2RlVG9UZXh0XyIsIm5ld05vZGUiLCJvbGROb2RlIiwiaXNDdXJzb3IiLCJtb2RhbCIsImhlYWRlciIsInF1ZXJ5U2VsZWN0b3IiLCJoZWFkZXJUZXh0IiwidGV4dENvbnRlbnQiLCJ0cmltIiwiYWRkQnV0dG9uTGlzdGVuZXJzXyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJtYWluVGV4dCIsImZvb3RlckJ0bnMiLCJidG5zIiwiYnRuIiwiYWRkRXZlbnRMaXN0ZW5lciIsImJ1dHRvblRvU3BlZWNoXyIsImRvY3VtZW50IiwiYWN0aXZlRWxlbWVudCIsImdldEF0dHJpYnV0ZSIsImxlbmd0aCIsIm5vZGUiLCJpc01hcmtlciIsImZpbmFsVGV4dCIsImdldFR5cGUiLCJBU1ROb2RlIiwidHlwZXMiLCJGSUVMRCIsImZpZWxkTm9kZVRvVGV4dF8iLCJCTE9DSyIsImJsb2NrTm9kZVRvVGV4dF8iLCJJTlBVVCIsImlucHV0Tm9kZVRvVGV4dF8iLCJPVVRQVVQiLCJvdXRwdXROb2RlVG9UZXh0XyIsIk5FWFQiLCJuZXh0Tm9kZVRvVGV4dF8iLCJQUkVWSU9VUyIsInByZXZpb3VzTm9kZVRvVGV4dF8iLCJTVEFDSyIsInN0YWNrTm9kZVRvVGV4dF8iLCJXT1JLU1BBQ0UiLCJ3b3Jrc3BhY2VOb2RlVG9UZXh0XyIsInRvU3RyaW5nIiwiZ2V0TmV4dE9wdGlvbnNfIiwiZ2V0RmllbGRPcHRpb25zXyIsImdldEJsb2NrT3B0aW9uc18iLCJnZXRDb25uZWN0aW9uT3B0aW9uc18iLCJnZXRTdGFja09wdGlvbnNfIiwiZmllbGQiLCJnZXRMb2NhdGlvbiIsImlzQ2xpY2thYmxlIiwibWFya2VyVGV4dCIsInByZXYiLCJzcmNCbG9jayIsIm9wdF9lbXB0eVRva2VuIiwiZW1wdHlUb2tlbiIsInN0YXRlbWVudElucHV0Q291bnQiLCJnZXRUZXh0IiwiYmxvY2siLCJibG9ja1RleHQiLCJnZXRCbG9ja1RleHRfIiwiZ2V0U3Vycm91bmRQYXJlbnQiLCJwYXJlbnRCbG9ja1RleHQiLCJpbnB1dENvbm5lY3Rpb24iLCJjb25uZWN0aW9uVGV4dCIsIk5FWFRfU1RBVEVNRU5UIiwiZ2V0U291cmNlQmxvY2siLCJJTlBVVF9WQUxVRSIsIm5ld05vZGVUb3BCbG9jayIsImdldFRvcFN0YWNrQmxvY2siLCJvbGROb2RlVG9wQmxvY2siLCJ3b3Jrc3BhY2UiLCJpc0ZseW91dCIsImlzTXV0YXRvciIsInNwZWFrZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ08sSUFBTUEsT0FBYjtBQUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0UsbUJBQVlDLFdBQVosRUFBeUI7QUFBQTs7QUFDdkIsUUFBTUMsUUFBUSxHQUFHO0FBQ2YsaUJBQVcsdUJBREk7QUFFZixlQUNJLG1FQUNBLDJEQUpXO0FBS2Ysa0JBQVksa0NBTEc7QUFNZixjQUFRLHlCQU5PO0FBT2YsZ0JBQVUsMkJBUEs7QUFRZixvQkFBYyx3QkFSQztBQVNmLGVBQVMsb0JBVE07QUFVZix5QkFBbUIs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RCxpQkFBUyxHQUFHLEtBQUtzQyxhQUFMLENBQW1CeEMsSUFBSSxDQUFDOEMsY0FBTCxFQUFuQixDQUFaO0FBQ0E1QyxpQkFBUyx1SkFBVDtBQUdELE9BTEQsTUFLTyxJQUFJK0IsUUFBSixFQUFjO0FBQ25CLFlBQUlpQixlQUFlLEtBQUtGLGVBQXhCLEVBQXlDO0FBQ3ZDOUMsbUJBQVMsd0NBQVQ7QUFDRCxTQUZELE1BRU87QUFDTEEsbUJBQVMsb0NBQVQ7QUFDRDtBQUNGOztBQUNELGFBQU9BLFNBQVA7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUExZEE7QUFBQTtBQUFBLHlDQTJkdUJGLElBM2R2QixFQTJkNkI7QUFDekIsVUFBTW1ELFNBQVM7QUFBRztBQUFvQ25ELFVBQUksQ0FBQzZCLFdBQUwsRUFBdEQsQ0FEeUIsQ0FFekI7O0FBQ0EsVUFBSXZFLElBQUksR0FBRyxJQUFYOztBQUNBLFVBQUk2RixTQUFTLENBQUNDLFFBQWQsRUFBd0I7QUFDdEI5RixZQUFJLEdBQUcsc0NBQVA7QUFDRCxPQUZELE1BRU8sSUFBSTZGLFNBQVMsQ0FBQ0UsU0FBZCxFQUF5QjtBQUM5Qi9GLFlBQUksR0FBRyxnRUFBUDtBQUNELE9BRk0sTUFFQTtBQUNMQSxZQUFJLEdBQUdYLG1EQUFPLENBQUNVLEdBQVIsQ0FBWSxTQUFaLENBQVA7QUFDRDs7QUFDRCxhQUFPQyxJQUFQO0FBQ0Q7QUF2ZUg7O0FBQUE7QUFBQTtBQTBlTyxJQUFNZ0csT0FBTyxHQUFHLElBQUk5RyxPQUFKLEVBQWhCIiwiZmlsZSI6Ii4vc3JjL3NwZWFrZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNwZWFrZXIgdXNlZCBmb3Igc3BlYWtpbmcgb3V0IHRleHQuXG4gKi9cblxuaW1wb3J0IEJsb2NrbHkgZnJvbSAnYmxvY2tseS9jb3JlJztcblxuLyoqXG4gKiBDb252ZW5pZW5jZSBtZXRob2RzIGZvciBzcGVha2luZyBvdXQgdGV4dC5cbiAqIE1vcmUgaW5mb3JtYXRpb24gb24gc3BlYWtlcnMgY2FuIGJlIGZvdW5kIGhlcmU6XG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU3BlZWNoU3ludGhlc2lzLlxuICovXG5leHBvcnQgY2xhc3MgU3BlYWtlciB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvciBmb3IgYSBzcGVha2VyLlxuICAgKiBAcGFyYW0ge1NwZWFrZXJNZXNzYWdlcz19IG9wdE1lc3NhZ2VzIE9wdGlvbmFsIG1lc3NhZ2VzIGZvciB0aGUgc3BlYWtlci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdE1lc3NhZ2VzKSB7XG4gICAgY29uc3QgbWVzc2FnZXMgPSB7XG4gICAgICAnTUFJTl9XUyc6ICdPbiB0aGUgbWFpbiB3b3Jrc3BhY2UnLFxuICAgICAgJ1NUQUNLJzpcbiAgICAgICAgICAnVG8gZ28gdG8gdGhlIGxhc3QgYmxvY2sgaW4gdGhlIHByZXZpb3VzIGdyb3VwIG9mIGJsb2NrcywgcHJlc3MnICtcbiAgICAgICAgICAncHJldmlvdXMuIFRvIGdvIHRvIHRoZSBmaXJzdCBibG9jayBpbiB0aGUgc3RhY2sgaGl0IG5leHQuJyxcbiAgICAgICdQUkVWSU9VUyc6ICdZb3UgYXJlIG9uIGEgY29ubmVjdGlvbiBiZWZvcmUsICcsXG4gICAgICAnTkVYVCc6ICdPbiBhIGNvbm5lY3Rpb24gYWZ0ZXIsICcsXG4gICAgICAnT1VUUFVUJzogJ09uIGFuIG91dHB1dCBjb25uZWN0aW9uLiAnLFxuICAgICAgJ0NPTk5FQ1RJT04nOiAnQXQgYSBjb25uZWN0aW9uIHBvaW50LicsXG4gICAgICAnQkxPQ0snOiAnT24gYSBibG9jayBvZiB0eXBlJyxcbiAgICAgICdDTElDS0FCTEVfRklFTEQnOiAnVG8gaW50ZXJhY3Qgd2l0aCB0aGUgZmllbGQgaGl0IGVudGVyLicsXG4gICAgICAnRU1QVFlfVE9LRU4nOiAnYmxhbmsnLFxuICAgICAgJ01BUktfQ09OTkVDVElPTic6ICdUbyBtYXJrIHRoZSBibG9jayBwcmVzcyBlbnRlci4gJyxcbiAgICAgICdFWElUX0VESVRfTU9ERSc6ICdUbyBleGl0IGVkaXQgbW9kZSBoaXQgZXNjYXBlLiAnLFxuICAgIH07XG5cbiAgICBCbG9ja2x5LnV0aWxzLm9iamVjdC5taXhpbihtZXNzYWdlcywgb3B0TWVzc2FnZXMpO1xuXG4gICAgdGhpcy5zZXRMb2NhbGUobWVzc2FnZXMpO1xuICAgIHRoaXMubm9PdmVycmlkZXMgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbWVzc2FnZXMgdG8gYmUgcmVhZCBvdXQgYnkgYSBzY3JlZW4gcmVhZGVyLlxuICAgKiBAdHlwZWRlZiB7e1xuICAgKiAgICAgTUFJTl9XUzogc3RyaW5nLFxuICAgKiAgICAgU1RBQ0s6IHN0cmluZyxcbiAgICogICAgIFBSRVZJT1VTOiBzdHJpbmcsXG4gICAqICAgICBORVhUOiBzdHJpbmcsXG4gICAqICAgICBPVVRQVVQ6IHN0cmluZyxcbiAgICogICAgIENPTk5FQ1RJT046IHN0cmluZyxcbiAgICogICAgIEJMT0NLOiBzdHJpbmcsXG4gICAqICAgICBFTVBUWV9UT0tFTjogc3RyaW5nLFxuICAgKiAgICAgTUFSS19DT05ORUNUSU9OOiBzdHJpbmcsXG4gICAqIH19IFNwZWFrZXJNZXNzYWdlc1xuICAgKi9cblxuICAvKipcbiAgICogU2V0IHRoZSBtZXNzYWdlcyBmb3IgdGhlIHNwZWFrZXIuXG4gICAqIEBwYXJhbSB7IVNwZWFrZXJNZXNzYWdlc30gbWVzc2FnZXMgVGhlIG1lc3NhZ2VzIG5lZWRlZCB0byBjcmVhdGUgYSBzcGVha2VyLlxuICAgKi9cbiAgc2V0TG9jYWxlKG1lc3NhZ2VzKSB7XG4gICAgT2JqZWN0LmtleXMobWVzc2FnZXMpLmZvckVhY2goKGspID0+IHtcbiAgICAgIEJsb2NrbHkuTXNnW2tdID0gbWVzc2FnZXNba107XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3BlYWtzIG91dCB0aGUgdGV4dCB0aGF0IHdhcyBnaXZlbiB0byBpdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHRleHQgdG8gc3BlYWsgb3V0LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBzaG91bGRDYW5jZWwgVHJ1ZSB0byBzdG9wIHRoZSBjdXJyZW50IHV0dGVyYW5jZSwgZmFsc2UgdG9cbiAgICogICAgIHdhaXQgdW50aWwgdGhlIGN1cnJlbnQgdXR0ZXJhbmNlIGlzIGRvbmUgYmVmb3JlIHNwZWFraW5nLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uPX0gb25FbmQgVGhlIGZ1bmN0aW9uIHRvIHJ1biBhZnRlciB0aGUgdGV4dCBoYXMgYmVlblxuICAgKiAgICAgc3Bva2VuLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uPX0gb25TdGFydCBUaGUgZnVuY3Rpb24gcnVuIHdoZW4gdGhlIHRleHQgaGFzIGJlZ3VuIHRvXG4gICAqICAgICBiZSBzcG9rZW4uXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNwZWFrKHRleHQsIHNob3VsZENhbmNlbCwgb25FbmQsIG9uU3RhcnQpIHtcbiAgICBjb25zdCBhdWRpbyA9IG5ldyBTcGVlY2hTeW50aGVzaXNVdHRlcmFuY2UodGV4dCk7XG5cbiAgICBpZiAoc2hvdWxkQ2FuY2VsICYmICF0aGlzLm5vT3ZlcnJpZGVzICYmIHdpbmRvdy5zcGVlY2hTeW50aGVzaXMuc3BlYWtpbmcpIHtcbiAgICAgIHdpbmRvdy5zcGVlY2hTeW50aGVzaXMuY2FuY2VsKCk7XG4gICAgfVxuXG4gICAgaWYgKG9uRW5kKSB7XG4gICAgICBhdWRpby5vbmVuZCA9IG9uRW5kO1xuICAgIH1cblxuICAgIGlmIChvblN0YXJ0KSB7XG4gICAgICBhdWRpby5vbnN0YXJ0ID0gb25TdGFydDtcbiAgICB9XG4gICAgd2luZG93LnNwZWVjaFN5bnRoZXNpcy5zcGVhayhhdWRpbyk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIG91dCB0aGUgcXVldWUgb2YgdGV4dCB0byBzcGVhay5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2FuY2VsKCkge1xuICAgIHdpbmRvdy5zcGVlY2hTeW50aGVzaXMuY2FuY2VsKCk7XG4gIH1cblxuICAvKipcbiAgICogUGF1c2VzIHNwZWFraW5nLlxuICAgKi9cbiAgcGF1c2UoKSB7XG4gICAgd2luZG93LnNwZWVjaFN5bnRoZXNpcy5wYXVzZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc3VtZXMgc3BlYWtpbmcuXG4gICAqL1xuICByZXN1bWUoKSB7XG4gICAgd2luZG93LnNwZWVjaFN5bnRoZXNpcy5yZXN1bWUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGVha3Mgb3V0IHRleHQgaWYgdGhlIGV2ZW50IGlzIG9mIHR5cGUgbWFya2VyIG9yIGN1cnNvciBtb3ZlLlxuICAgKiBAcGFyYW0geyFCbG9ja2x5LkV2ZW50c30gZXZlbnQgVGhlIGV2ZW50IHRvIHNwZWFrIG91dC5cbiAgICovXG4gIG5vZGVUb1NwZWVjaChldmVudCkge1xuICAgIC8vIFRPRE86IFVwZGF0ZSB0aGlzIGlmIHdlIGxpbmsgdG8gdGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBibG9ja2x5LlxuICAgIGlmIChldmVudC50eXBlID09PSBCbG9ja2x5LkV2ZW50cy5NQVJLRVJfTU9WRSkge1xuICAgICAgbGV0IG5vZGVUZXh0ID1cbiAgICAgICAgICB0aGlzLm5vZGVUb1RleHRfKGV2ZW50Lm5ld05vZGUsIGV2ZW50Lm9sZE5vZGUsICFldmVudC5pc0N1cnNvcik7XG4gICAgICBpZiAoIWV2ZW50LmlzQ3Vyc29yKSB7XG4gICAgICAgIG5vZGVUZXh0ID0gYFlvdSBoYXZlIG1hcmtlZCBhIGxvY2F0aW9uLiBUbyBmaW5kIGEgbmV3IGJsb2NrIHRvIGNvbm5lY3RcbiAgICAgICAgdG8gdGhpcyBsb2NhdGlvbiBoaXQgVC4gISAuIFRvIGluc2VydCBhIGJsb2NrIG9uIHRoZSB3b3Jrc3BhY2UsXG4gICAgICAgIGZpbmQgdGhlIGxvY2F0aW9uIG9mIHRoZSBibG9jayBhbmQgaGl0IEkuIGA7XG4gICAgICB9XG4gICAgICB0aGlzLnNwZWFrKG5vZGVUZXh0LCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3BlYWtzIG91dCB0aGUgdGV4dCBmb3IgYSBtb2RhbC5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBtb2RhbCBUaGUgbW9kYWwgdG8gY29sbGVjdCB0aGUgdGV4dCB0byByZWFkIG91dC5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgbW9kYWxUb1RleHQobW9kYWwpIHtcbiAgICBjb25zdCBoZWFkZXIgPSBtb2RhbC5xdWVyeVNlbGVjdG9yKCdoZWFkZXInKTtcbiAgICBjb25zdCBoZWFkZXJUZXh0ID0gaGVhZGVyLnRleHRDb250ZW50LnRyaW0oKTtcbiAgICBpZiAoaGVhZGVyVGV4dCAhPT0gJycpIHtcbiAgICAgIHRoaXMuc3BlYWsoaGVhZGVyVGV4dCk7XG4gICAgfVxuICAgIHRoaXMuYWRkQnV0dG9uTGlzdGVuZXJzXyhoZWFkZXIucXVlcnlTZWxlY3RvckFsbCgnYnV0dG9uJykpO1xuXG4gICAgY29uc3QgbWFpblRleHQgPSBtb2RhbC5xdWVyeVNlbGVjdG9yKCdtYWluJykudGV4dENvbnRlbnQudHJpbSgpO1xuXG4gICAgaWYgKG1haW5UZXh0ICE9PSAnJykge1xuICAgICAgdGhpcy5zcGVhayhtYWluVGV4dCk7XG4gICAgfVxuXG4gICAgY29uc3QgZm9vdGVyQnRucyA9IG1vZGFsLnF1ZXJ5U2VsZWN0b3IoJ2Zvb3RlcicpLnF1ZXJ5U2VsZWN0b3JBbGwoJ2J1dHRvbicpO1xuICAgIHRoaXMuYWRkQnV0dG9uTGlzdGVuZXJzXyhmb290ZXJCdG5zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGxpc3RlbmVycyBmb3Igd2hlbiB0aGUgYnV0dG9uIGlzIGZvY3VzZWQuXG4gICAqIEBwYXJhbSB7IU5vZGVMaXN0fSBidG5zIFRoZSBidXR0b25zIHRvIGFkZCBsaXN0ZW5lcnMgdG8uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhZGRCdXR0b25MaXN0ZW5lcnNfKGJ0bnMpIHtcbiAgICBmb3IgKGNvbnN0IGJ0biBvZiBidG5zKSB7XG4gICAgICBidG4uYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuYnV0dG9uVG9TcGVlY2hfKGJ0bnMsIGJ0biwgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBidG4pIHtcbiAgICAgICAgdGhpcy5idXR0b25Ub1NwZWVjaF8oYnRucywgYnRuLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNwZWFrcyBvdXQgaW5mb3JtYXRpb24gYWJvdXQgYSBidXR0b24uXG4gICAqIEBwYXJhbSB7Tm9kZUxpc3R9IGJ0bnMgVGhlIGxpc3Qgb2YgYnV0dG9ucyBvbiB0aGUgbW9kYWwuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gYnRuIFRoZSBidXR0b24uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkQ2FuY2VsIFRydWUgaWYgdGhpcyBzaG91bGQgY2FuY2VsIHRoZSBwcmV2aW91c1xuICAgKiAgICAgdXR0ZXJhbmNlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYnV0dG9uVG9TcGVlY2hfKGJ0bnMsIGJ0biwgc2hvdWxkQ2FuY2VsKSB7XG4gICAgdGhpcy5zcGVhaygnSGl0IGVudGVyIHRvICcsIHNob3VsZENhbmNlbCk7XG4gICAgaWYgKGJ0bi50ZXh0Q29udGVudCA9PT0gJycpIHtcbiAgICAgIHRoaXMuc3BlYWsoYnRuLmdldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zcGVhayhidG4udGV4dENvbnRlbnQpO1xuICAgIH1cbiAgICBpZiAoYnRucy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnNwZWFrKCdIaXQgdGFiIHRvIGdvIHRvIHlvdXIgbmV4dCBvcHRpb24nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3BlYWtzIG91dCBhbiBhdWRpbyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gbm9kZS5cbiAgICogQHBhcmFtIHtCbG9ja2x5LkFTVE5vZGV9IG5vZGUgVGhlIG5vZGUgdG8gc3BlYWsgb3V0LlxuICAgKiBAcGFyYW0ge0Jsb2NrbHkuQVNUTm9kZX0gb2xkTm9kZSBUaGUgcHJldmlvdXMgbm9kZSB0byBzcGVhayBvdXQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNNYXJrZXIgVHJ1ZSB0byBnZXQgdGhlIHRleHQgZm9yIGEgbWFya2VyLFxuICAgKiAgICAgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB0ZXh0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBub2RlLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBub2RlVG9UZXh0Xyhub2RlLCBvbGROb2RlLCBpc01hcmtlcikge1xuICAgIGxldCBmaW5hbFRleHQgPSAnJztcbiAgICBzd2l0Y2ggKG5vZGUuZ2V0VHlwZSgpKSB7XG4gICAgICBjYXNlIEJsb2NrbHkuQVNUTm9kZS50eXBlcy5GSUVMRDpcbiAgICAgICAgZmluYWxUZXh0ID0gdGhpcy5maWVsZE5vZGVUb1RleHRfKG5vZGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQmxvY2tseS5BU1ROb2RlLnR5cGVzLkJMT0NLOlxuICAgICAgICBmaW5hbFRleHQgPSB0aGlzLmJsb2NrTm9kZVRvVGV4dF8obm9kZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBCbG9ja2x5LkFTVE5vZGUudHlwZXMuSU5QVVQ6XG4gICAgICAgIGZpbmFsVGV4dCA9IHRoaXMuaW5wdXROb2RlVG9UZXh0Xyhub2RlLCBpc01hcmtlcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBCbG9ja2x5LkFTVE5vZGUudHlwZXMuT1VUUFVUOlxuICAgICAgICBmaW5hbFRleHQgPSB0aGlzLm91dHB1dE5vZGVUb1RleHRfKG5vZGUsIGlzTWFya2VyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEJsb2NrbHkuQVNUTm9kZS50eXBlcy5ORVhUOlxuICAgICAgICBmaW5hbFRleHQgPSB0aGlzLm5leHROb2RlVG9UZXh0Xyhub2RlLCBpc01hcmtlcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBCbG9ja2x5LkFTVE5vZGUudHlwZXMuUFJFVklPVVM6XG4gICAgICAgIGZpbmFsVGV4dCA9IHRoaXMucHJldmlvdXNOb2RlVG9UZXh0Xyhub2RlLCBpc01hcmtlcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBCbG9ja2x5LkFTVE5vZGUudHlwZXMuU1RBQ0s6XG4gICAgICAgIGZpbmFsVGV4dCA9IHRoaXMuc3RhY2tOb2RlVG9UZXh0Xyhub2RlLCBvbGROb2RlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEJsb2NrbHkuQVNUTm9kZS50eXBlcy5XT1JLU1BBQ0U6XG4gICAgICAgIGZpbmFsVGV4dCA9IHRoaXMud29ya3NwYWNlTm9kZVRvVGV4dF8obm9kZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG5vZGUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgZmluYWxUZXh0ICs9IHRoaXMuZ2V0TmV4dE9wdGlvbnNfKG5vZGUsIG9sZE5vZGUsIGlzTWFya2VyKTtcbiAgICByZXR1cm4gZmluYWxUZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGV4dCBleHBsYWluaW5nIHRoZSBuZXh0IG9wdGlvbnMgYXZhaWxhYmxlIGZvciBhIHVzZXIuXG4gICAqIEBwYXJhbSB7IUJsb2NrbHkuQVNUTm9kZX0gbm9kZSBUaGUgY3VycmVudCBub2RlLlxuICAgKiBAcGFyYW0geyFCbG9ja2x5LkFTVE5vZGV9IG9sZE5vZGUgVGhlIHByZXZpb3VzIG5vZGUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNNYXJrZXIgVHJ1ZSBpZiB0aGUgbWFya2VyIHdhcyBtb3ZlZC5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUZXh0IGV4cGxhaW5pbmcgbmV4dCBvcHRpb25zIGZvciB0aGUgZmllbGQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXROZXh0T3B0aW9uc18obm9kZSwgb2xkTm9kZSwgaXNNYXJrZXIpIHtcbiAgICBzd2l0Y2ggKG5vZGUuZ2V0VHlwZSgpKSB7XG4gICAgICBjYXNlIEJsb2NrbHkuQVNUTm9kZS50eXBlcy5GSUVMRDpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmllbGRPcHRpb25zXyhub2RlKTtcbiAgICAgIGNhc2UgQmxvY2tseS5BU1ROb2RlLnR5cGVzLkJMT0NLOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRCbG9ja09wdGlvbnNfKG5vZGUpO1xuICAgICAgY2FzZSBCbG9ja2x5LkFTVE5vZGUudHlwZXMuSU5QVVQ6XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbm5lY3Rpb25PcHRpb25zXyhub2RlLCBpc01hcmtlcik7XG4gICAgICBjYXNlIEJsb2NrbHkuQVNUTm9kZS50eXBlcy5PVVRQVVQ6XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbm5lY3Rpb25PcHRpb25zXyhub2RlLCBpc01hcmtlcik7XG4gICAgICBjYXNlIEJsb2NrbHkuQVNUTm9kZS50eXBlcy5ORVhUOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb25uZWN0aW9uT3B0aW9uc18obm9kZSwgaXNNYXJrZXIpO1xuICAgICAgY2FzZSBCbG9ja2x5LkFTVE5vZGUudHlwZXMuUFJFVklPVVM6XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbm5lY3Rpb25PcHRpb25zXyhub2RlLCBpc01hcmtlcik7XG4gICAgICBjYXNlIEJsb2NrbHkuQVNUTm9kZS50eXBlcy5TVEFDSzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhY2tPcHRpb25zXyhub2RlKTtcbiAgICAgIGNhc2UgQmxvY2tseS5BU1ROb2RlLnR5cGVzLldPUktTUEFDRTpcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG5vZGUudG9TdHJpbmcoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbmV4dCBvcHRpb25zIGZvciB3aGVuIGEgdXNlciBpcyBvbiBhIGZpZWxkLlxuICAgKiBUaGlzIGlzIHRvIG9wZW4gdGhlIGZpZWxkIG9yIHRvIGNoYW5nZSBsb2NhdGlvbnMuXG4gICAqIEBwYXJhbSB7IUJsb2NrbHkuQVNUTm9kZX0gbm9kZSBUaGUgZmllbGQgbm9kZS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgdGV4dCBleHBsYWluaW5nIHRoZSBuZXh0IG9wdGlvbnMgd2hlbiBhIHVzZXIgaXMgb24gYVxuICAgKiAgICAgZmllbGQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRGaWVsZE9wdGlvbnNfKG5vZGUpIHtcbiAgICBjb25zdCBmaWVsZCA9IG5vZGUuZ2V0TG9jYXRpb24oKTtcbiAgICBpZiAoZmllbGQuaXNDbGlja2FibGUoKSkge1xuICAgICAgcmV0dXJuIGBUbyBpbnRlcmFjdCB3aXRoIHRoZSBmaWVsZCBoaXQgZW50ZXIuIFVzZSB0aGUgbmV4dCBvciBwcmV2aW91c1xuICAgICAga2V5cyB0byBjaGFuZ2UgbG9jYXRpb25zLiBgO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJ1VzZSB0aGUgbmV4dCBvciBwcmV2aW91cyBrZXlzIHRvIGNoYW5nZSBsb2NhdGlvbnMuICc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG5leHQgb3B0aW9ucyBmb3Igd2hlbiBhIHVzZXIgaXMgb24gYSBibG9jay5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgdGV4dCBleHBsYWluaW5nIHRoZSBuZXh0IG9wdGlvbnMgZm9yIGEgYmxvY2suXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRCbG9ja09wdGlvbnNfKCkge1xuICAgIHJldHVybiBgVXNlIHRoZSBuZXh0IG9yIHByZXZpb3VzIGtleXMgdG8gY2hhbmdlIGxvY2F0aW9ucy4gYDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB0ZXh0IGZvciB0aGUgY29ubmVjdGlvbiBwb2ludC5cbiAgICogQHBhcmFtIHshQmxvY2tseS5BU1ROb2RlfSBub2RlIFRoZSBjb25uZWN0aW9uIG5vZGUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNNYXJrZXIgVHJ1ZSBpZiB0aGUgbWFya2VyIHdhcyBtb3ZlZC5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgdGV4dCBleHBsYWluaW5nIHRoZSBuZXh0IG9wdGlvbnMgd2hlbiBhIHVzZXIgaXMgb24gYVxuICAgKiAgICAgY29ubmVjdGlvbi5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldENvbm5lY3Rpb25PcHRpb25zXyhub2RlLCBpc01hcmtlcikge1xuICAgIGNvbnN0IG1hcmtlclRleHQgPSBgLiBUbyBtYXJrIHRoaXMgbG9jYXRpb24sIGhpdCBlbnRlci5cbiAgICBUbyBjaGFuZ2UgbG9jYXRpb25zIHVzZSB0aGUgbmV4dCBvciBwcmV2aW91cyBrZXlzYDtcbiAgICBsZXQgZmluYWxUZXh0ID0gJyc7XG4gICAgaWYgKCFpc01hcmtlcikge1xuICAgICAgZmluYWxUZXh0ICs9IGAke21hcmtlclRleHR9YDtcbiAgICB9XG4gICAgcmV0dXJuIGZpbmFsVGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBvcHRpb25zIGZvciBhIHVzZXIgb24gYSAgc3RhY2sgb2YgYmxvY2tzLlxuICAgKiBAcGFyYW0ge0Jsb2NrbHkuQVNUTm9kZX0gbm9kZSBUaGUgc3RhY2sgbm9kZS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgdGV4dCBleHBsYWluaW5nIHRoZSBuZXh0IG9wdGlvbnMgd2hlbiBhIHVzZXIgaXMgb24gYVxuICAgKiAgICAgc3RhY2sgb2YgYmxvY2tzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0U3RhY2tPcHRpb25zXyhub2RlKSB7XG4gICAgbGV0IGZpbmFsVGV4dCA9ICcnO1xuICAgIGlmIChub2RlLnByZXYoKSkge1xuICAgICAgZmluYWxUZXh0ICs9IGBUbyBnbyB0byB0aGUgbGFzdCBibG9jayBpbiB0aGUgcHJldmlvdXMgZ3JvdXAgb2YgYmxvY2tzLFxuICAgICAgcHJlc3MgcHJldmlvdXMuYDtcbiAgICB9XG4gICAgZmluYWxUZXh0ICs9IGAgVG8gZ28gdG8gdGhlIGZpcnN0IGJsb2NrIGluIHRoZSBzdGFjayBoaXQgbmV4dC5gO1xuICAgIHJldHVybiBmaW5hbFRleHQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0ZXh0IGZvciB0aGUgc291cmNlIGJsb2NrIG9mIHRoZSBub2RlLlxuICAgKiBAcGFyYW0geyFCbG9ja2x5LkJsb2NrU3ZnfSBzcmNCbG9jayBUaGUgYmxvY2sgdG8gZ2V0IHRoZSB0ZXh0IGZvci5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfZW1wdHlUb2tlbiBUaGUgb3B0aW9uYWwgZW1wdHkgdG9rZW4uXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHRleHQgZGVzY3JpYmluZyB0aGUgc291cmNlIGJsb2NrIG9mIHRoZSBub2RlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0QmxvY2tUZXh0XyhzcmNCbG9jaywgb3B0X2VtcHR5VG9rZW4pIHtcbiAgICBsZXQgZW1wdHlUb2tlbiA9IG9wdF9lbXB0eVRva2VuIHx8IEJsb2NrbHkuTXNnWydFTVBUWV9UT0tFTiddO1xuICAgIGlmIChzcmNCbG9jaykge1xuICAgICAgaWYgKHNyY0Jsb2NrLnN0YXRlbWVudElucHV0Q291bnQgPiAwKSB7XG4gICAgICAgIGVtcHR5VG9rZW4gPSAnIGRvIGJsYW5rICc7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3JjQmxvY2sudG9TdHJpbmcobnVsbCwgZW1wdHlUb2tlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyB0ZXh0IGZvciBhIGZlaWxkLlxuICAgKiBAcGFyYW0geyFCbG9ja2x5LkFTVE5vZGV9IG5vZGUgVGhlIG5vZGUgdG8gY3JlYXRlIHRleHQgZm9yLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB0ZXh0IGZvciB0aGUgc2NyZWVuIHJlYWRlciB0byByZWFkIG91dC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZmllbGROb2RlVG9UZXh0Xyhub2RlKSB7XG4gICAgY29uc3QgZmllbGQgPSBub2RlLmdldExvY2F0aW9uKCk7XG4gICAgcmV0dXJuIGZpZWxkLmdldFRleHQoKSArICcuICc7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyB0ZXh0IGZvciBhIGZlaWxkLlxuICAgKiBAcGFyYW0geyFCbG9ja2x5LkFTVE5vZGV9IG5vZGUgVGhlIG5vZGUgdG8gY3JlYXRlIHRleHQgZm9yLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB0ZXh0IGZvciB0aGUgc2NyZWVuIHJlYWRlciB0byByZWFkIG91dC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgYmxvY2tOb2RlVG9UZXh0Xyhub2RlKSB7XG4gICAgY29uc3QgYmxvY2sgPSAvKiogQHR5cGV7QmxvY2tseS5CbG9ja1N2Z30gKi8gKG5vZGUuZ2V0TG9jYXRpb24oKSk7XG4gICAgY29uc3QgYmxvY2tUZXh0ID0gdGhpcy5nZXRCbG9ja1RleHRfKGJsb2NrKTtcbiAgICBsZXQgZmluYWxUZXh0ID0gJyc7XG4gICAgaWYgKGJsb2NrLmdldFN1cnJvdW5kUGFyZW50KCkpIHtcbiAgICAgIGNvbnN0IHBhcmVudEJsb2NrVGV4dCA9IHRoaXMuZ2V0QmxvY2tUZXh0XyhibG9jay5nZXRTdXJyb3VuZFBhcmVudCgpKTtcbiAgICAgIGZpbmFsVGV4dCArPSBgWW91IGFyZSBpbnNpZGUgb2YgYmxvY2sgJHtwYXJlbnRCbG9ja1RleHR9LiAuIGA7XG4gICAgfVxuICAgIGZpbmFsVGV4dCArPSBgWW91IGFyZSBvbiAsICR7YmxvY2tUZXh0fS4gLiBgO1xuICAgIHJldHVybiBmaW5hbFRleHQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyB0ZXh0IGZvciBhbiBpbnB1dC5cbiAgICogQHBhcmFtIHshQmxvY2tseS5BU1ROb2RlfSBub2RlIFRoZSBub2RlIHRvIGNyZWF0ZSB0ZXh0IGZvci5cbiAgICogQHBhcmFtIHtib29sZWFufSBpc01hcmtlciBUcnVlIGlmIHRoZSBtYXJrZXIgd2FzIG1vdmVkLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB0ZXh0IGZvciB0aGUgc2NyZWVuIHJlYWRlciB0byByZWFkIG91dC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgaW5wdXROb2RlVG9UZXh0Xyhub2RlLCBpc01hcmtlcikge1xuICAgIGNvbnN0IGlucHV0Q29ubmVjdGlvbiA9IC8qKiBAdHlwZXtCbG9ja2x5LklucHV0fSAqLyAobm9kZS5nZXRMb2NhdGlvbigpKTtcbiAgICBjb25zdCBjb25uZWN0aW9uVGV4dCA9IGBZb3UgYXJlIG9uIGEgY29ubmVjdGlvbmA7XG4gICAgbGV0IGZpbmFsVGV4dCA9ICcnO1xuICAgIGlmIChpbnB1dENvbm5lY3Rpb24udHlwZSA9PT0gQmxvY2tseS5ORVhUX1NUQVRFTUVOVCkge1xuICAgICAgY29uc3QgYmxvY2tUZXh0ID0gdGhpcy5nZXRCbG9ja1RleHRfKG5vZGUuZ2V0U291cmNlQmxvY2soKSk7XG4gICAgICBmaW5hbFRleHQgPSBgSW5zaWRlICR7YmxvY2tUZXh0fS4gJHtjb25uZWN0aW9uVGV4dH0uIGA7XG4gICAgfSBlbHNlIGlmIChpbnB1dENvbm5lY3Rpb24udHlwZSA9PT0gQmxvY2tseS5JTlBVVF9WQUxVRSkge1xuICAgICAgY29uc3QgYmxvY2tUZXh0ID0gdGhpcy5nZXRCbG9ja1RleHRfKG5vZGUuZ2V0U291cmNlQmxvY2soKSwgJyAnKTtcbiAgICAgIGZpbmFsVGV4dCA9IGAke2Nvbm5lY3Rpb25UZXh0fSBhZnRlciAke2Jsb2NrVGV4dH1gO1xuICAgIH1cbiAgICByZXR1cm4gZmluYWxUZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGV4dCBmb3IgYSBvdXRwdXQgY29ubmVjdGlvbi5cbiAgICogQHBhcmFtIHshQmxvY2tseS5BU1ROb2RlfSBub2RlIFRoZSBub2RlIHRvIGNyZWF0ZSB0ZXh0IGZvci5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgdGV4dCBmb3IgdGhlIHNjcmVlbiByZWFkZXIgdG8gcmVhZCBvdXQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIG91dHB1dE5vZGVUb1RleHRfKG5vZGUpIHtcbiAgICBjb25zdCBibG9ja1RleHQgPSB0aGlzLmdldEJsb2NrVGV4dF8obm9kZS5nZXRTb3VyY2VCbG9jaygpKTtcbiAgICByZXR1cm4gYFlvdSBhcmUgb24gYSBjb25uZWN0aW9uIGZvciBibG9jaywgJHtibG9ja1RleHR9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRleHQgZm9yIGEgbmV4dCBjb25uZWN0aW9uLlxuICAgKiBAcGFyYW0geyFCbG9ja2x5LkFTVE5vZGV9IG5vZGUgVGhlIG5vZGUgdG8gY3JlYXRlIHRleHQgZm9yLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTWFya2VyIFRydWUgdG8gZ2V0IHRoZSB0ZXh0IGZvciBhIG1hcmtlcixcbiAgICogICAgIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgdGV4dCBmb3IgdGhlIHNjcmVlbiByZWFkZXIgdG8gcmVhZCBvdXQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIG5leHROb2RlVG9UZXh0Xyhub2RlLCBpc01hcmtlcikge1xuICAgIGNvbnN0IGJsb2NrID0gbm9kZS5nZXRTb3VyY2VCbG9jaygpO1xuICAgIGNvbnN0IGJsb2NrVGV4dCA9IHRoaXMuZ2V0QmxvY2tUZXh0Xyhub2RlLmdldFNvdXJjZUJsb2NrKCkpO1xuICAgIGxldCBmaW5hbFRleHQgPSAnJztcbiAgICBpZiAoYmxvY2suZ2V0U3Vycm91bmRQYXJlbnQoKSkge1xuICAgICAgY29uc3QgcGFyZW50QmxvY2tUZXh0ID0gdGhpcy5nZXRCbG9ja1RleHRfKGJsb2NrLmdldFN1cnJvdW5kUGFyZW50KCkpO1xuICAgICAgZmluYWxUZXh0ICs9IGBZb3UgYXJlIGluc2lkZSBvZiBibG9jayAke3BhcmVudEJsb2NrVGV4dH0uIC4gYDtcbiAgICB9XG4gICAgZmluYWxUZXh0ICs9IGAke0Jsb2NrbHkuTXNnWydORVhUJ119ICR7YmxvY2tUZXh0fWA7XG4gICAgcmV0dXJuIGZpbmFsVGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRleHQgZm9yIGEgcHJldmlvdXMgY29ubmVjdGlvbi5cbiAgICogQHBhcmFtIHshQmxvY2tseS5BU1ROb2RlfSBub2RlIFRoZSBub2RlIHRvIGNyZWF0ZSB0ZXh0IGZvci5cbiAgICogQHBhcmFtIHtib29sZWFufSBpc01hcmtlciBUcnVlIHRvIGdldCB0aGUgdGV4dCBmb3IgYSBtYXJrZXIsXG4gICAqICAgICBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHRleHQgZm9yIHRoZSBzY3JlZW4gcmVhZGVyIHRvIHJlYWQgb3V0LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBwcmV2aW91c05vZGVUb1RleHRfKG5vZGUsIGlzTWFya2VyKSB7XG4gICAgY29uc3QgYmxvY2sgPSBub2RlLmdldFNvdXJjZUJsb2NrKCk7XG4gICAgY29uc3QgYmxvY2tUZXh0ID0gdGhpcy5nZXRCbG9ja1RleHRfKGJsb2NrKTtcbiAgICBsZXQgZmluYWxUZXh0ID0gJyc7XG4gICAgaWYgKGJsb2NrLmdldFN1cnJvdW5kUGFyZW50KCkpIHtcbiAgICAgIGNvbnN0IHBhcmVudEJsb2NrVGV4dCA9IHRoaXMuZ2V0QmxvY2tUZXh0XyhibG9jay5nZXRTdXJyb3VuZFBhcmVudCgpKTtcbiAgICAgIGZpbmFsVGV4dCArPSBgWW91IGFyZSBpbnNpZGUgb2YgYmxvY2sgJHtwYXJlbnRCbG9ja1RleHR9LiAuIGA7XG4gICAgfVxuXG4gICAgZmluYWxUZXh0ICs9IGAke0Jsb2NrbHkuTXNnWydQUkVWSU9VUyddfSAke2Jsb2NrVGV4dH1gO1xuICAgIHJldHVybiBmaW5hbFRleHQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyB0ZXh0IGZvciBhIHN0YWNrIG9mIGJsb2Nrcy5cbiAgICogQHBhcmFtIHshQmxvY2tseS5BU1ROb2RlfSBub2RlIFRoZSBub2RlIHRvIGNyZWF0ZSB0ZXh0IGZvci5cbiAgICogQHBhcmFtIHshQmxvY2tseS5BU1ROb2RlfSBvbGROb2RlIFRoZSBwcmV2aW91cyBub2RlLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB0ZXh0IGZvciB0aGUgc2NyZWVuIHJlYWRlciB0byByZWFkIG91dC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgc3RhY2tOb2RlVG9UZXh0Xyhub2RlLCBvbGROb2RlKSB7XG4gICAgY29uc3Qgc3JjQmxvY2sgPSBub2RlLmdldFNvdXJjZUJsb2NrKCk7XG4gICAgY29uc3QgbmV3Tm9kZVRvcEJsb2NrID0gc3JjQmxvY2suZ2V0VG9wU3RhY2tCbG9jaygpO1xuICAgIGxldCBvbGROb2RlVG9wQmxvY2sgPSBudWxsO1xuICAgIGlmIChvbGROb2RlICYmIG9sZE5vZGUuZ2V0U291cmNlQmxvY2soKSkge1xuICAgICAgb2xkTm9kZVRvcEJsb2NrID0gb2xkTm9kZS5nZXRTb3VyY2VCbG9jaygpLmdldFRvcFN0YWNrQmxvY2soKTtcbiAgICB9XG5cbiAgICBsZXQgZmluYWxUZXh0ID0gJyc7XG5cbiAgICBpZiAoc3JjQmxvY2sgJiYgc3JjQmxvY2sud29ya3NwYWNlLmlzRmx5b3V0KSB7XG4gICAgICBmaW5hbFRleHQgPSB0aGlzLmdldEJsb2NrVGV4dF8obm9kZS5nZXRTb3VyY2VCbG9jaygpKTtcbiAgICAgIGZpbmFsVGV4dCArPSBgIC4gLiBUbyBhZGQgdGhpcyBibG9jayB0byB0aGUgd29ya3NwYWNlIHByZXNzIEVudGVyLiAuXG4gICAgICBUbyBnbyB0byB0aGUgbmV4dCBibG9jayBoaXQgbmV4dC4gLiBUbyBnbyBiYWNrIHRvIHRoZSB3b3Jrc3BhY2VcbiAgICAgIGhpdCBlc2NhcGUuIGA7XG4gICAgfSBlbHNlIGlmIChzcmNCbG9jaykge1xuICAgICAgaWYgKG9sZE5vZGVUb3BCbG9jayAhPT0gbmV3Tm9kZVRvcEJsb2NrKSB7XG4gICAgICAgIGZpbmFsVGV4dCArPSBgWW91IGFyZSBvbiBhIG5ldyBncm91cCBvZiBibG9ja3MuIGA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaW5hbFRleHQgKz0gYFlvdSBhcmUgb24gYSBncm91cCBvZiBibG9ja3MuIGA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaW5hbFRleHQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyB0ZXh0IGZvciBhIHdvcmtzcGFjZS5cbiAgICogQHBhcmFtIHshQmxvY2tseS5BU1ROb2RlfSBub2RlIFRoZSBub2RlIHRvIGNyZWF0ZSB0ZXh0IGZvci5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgdGV4dCBmb3IgdGhlIHNjcmVlbiByZWFkZXIgdG8gcmVhZCBvdXQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHdvcmtzcGFjZU5vZGVUb1RleHRfKG5vZGUpIHtcbiAgICBjb25zdCB3b3Jrc3BhY2UgPSAvKiogQHR5cGV7QmxvY2tseS5Xb3Jrc3BhY2VTdmd9ICovIChub2RlLmdldExvY2F0aW9uKCkpO1xuICAgIC8vIFRPRE86IEFsbCB0ZXh0IHNob3VsZCBiZSBhZGRlZCB0byBCbG9ja2x5Lk1zZyB0byBhbGxvdyBmb3IgdHJhbnNsYXRpb24uXG4gICAgbGV0IHRleHQgPSBudWxsO1xuICAgIGlmICh3b3Jrc3BhY2UuaXNGbHlvdXQpIHtcbiAgICAgIHRleHQgPSAnSW4gdGhlIGZseW91dCwgcGxlYXNlIHNlbGVjdCBhIGJsb2NrJztcbiAgICB9IGVsc2UgaWYgKHdvcmtzcGFjZS5pc011dGF0b3IpIHtcbiAgICAgIHRleHQgPSAnSW4gdGhlIG11dGF0b3Igd29ya3NwYWNlLCB1c2UgdGhpcyB3b3Jrc3BhY2UgdG8gY2hhbmdlIGEgYmxvY2snO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ZXh0ID0gQmxvY2tseS5Nc2dbJ01BSU5fV1MnXTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNwZWFrZXIgPSBuZXcgU3BlYWtlcigpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/speaker.js\n");

/***/ })

})
webpackHotUpdate("main",{

/***/ "./src/speaker.js":
/*!************************!*\
  !*** ./src/speaker.js ***!
  \************************/
/*! exports provided: Speaker, speaker */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Speaker\", function() { return Speaker; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"speaker\", function() { return speaker; });\n/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ \"./node_modules/blockly/dist/core-browser.js\");\n/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Speaker used for speaking out text.\n */\n\n/**\n * Convenience methods for speaking out text.\n * More information on speakers can be found here:\n * https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesis.\n */\n\nvar Speaker = /*#__PURE__*/function () {\n  /**\n   * Constructor for a speaker.\n   * @param {SpeakerMessages=} optMessages Optional messages for the speaker.\n   */\n  function Speaker(optMessages) {\n    _classCallCheck(this, Speaker);\n\n    var messages = {\n      'MAIN_WS': 'On the main workspace',\n      'STACK': 'To go to the last block in the previous group of blocks, press' + 'previous. To go to the first block in the stack hit next.',\n      'PREVIOUS': 'You are on a connection before, ',\n      'NEXT': 'On a connection after, ',\n      'OUTPUT': 'On an output connection. ',\n      'CONNECTION': 'At a connection point.',\n      'BLOCK': 'On a block of type',\n      'CLICKABLE_FIELD': 'To interact with the field hit enter.',\n      'EMPTY_TOKEN': 'blank',\n      'MARK_CONNECTION': 'To mark the block press enter. ',\n      'EXIT_EDIT_MODE': 'To exit edit mode hit escape. '\n    };\n    blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.utils.object.mixin(messages, optMessages);\n    this.setLocale(messages);\n    this.noOverrides = false;\n  }\n  /**\n   * The messages to be read out by a screen reader.\n   * @typedef {{\n   *     MAIN_WS: string,\n   *     STACK: string,\n   *     PREVIOUS: string,\n   *     NEXT: string,\n   *     OUTPUT: string,\n   *     CONNECTION: string,\n   *     BLOCK: string,\n   *     EMPTY_TOKEN: string,\n   *     MARK_CONNECTION: string,\n   * }} SpeakerMessages\n   */\n\n  /**\n   * Set the messages for the speaker.\n   * @param {!SpeakerMessages} messages The messages needed to create a speaker.\n   */\n\n\n  _createClass(Speaker, [{\n    key: \"setLocale\",\n    value: function setLocale(messages) {\n      Object.keys(messages).forEach(function (k) {\n        blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.Msg[k] = messages[k];\n      });\n    }\n    /**\n     * Speaks out the text that was given to it.\n     * @param {string} text The text to speak out.\n     * @param {boolean=} shouldCancel True to stop the current utterance, false to\n     *     wait until the current utterance is done before speaking.\n     * @param {function=} onEnd The function to run after the text has been\n     *     spoken.\n     * @param {function=} onStart The function run when the text has begun to\n     *     be spoken.\n     * @public\n     */\n\n  }, {\n    key: \"speak\",\n    value: function speak(text, shouldCancel, onEnd, onStart) {\n      var audio = new SpeechSynthesisUtterance(text);\n\n      if (shouldCancel && !this.noOverrides && window.speechSynthesis.speaking) {\n        window.speechSynthesis.cancel();\n      }\n\n      if (onEnd) {\n        audio.onend = onEnd;\n      }\n\n      if (onStart) {\n        audio.onstart = onStart;\n      }\n\n      window.speechSynthesis.speak(audio);\n    }\n    /**\n     * Clears out the queue of text to speak.\n     * @public\n     */\n\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      window.speechSynthesis.cancel();\n    }\n    /**\n     * Pauses speaking.\n     */\n\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      window.speechSynthesis.pause();\n    }\n    /**\n     * Resumes speaking.\n     */\n\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      window.speechSynthesis.resume();\n    }\n    /**\n     * Speaks out text if the event is of type marker or cursor move.\n     * @param {!Blockly.Events} event The event to speak out.\n     */\n\n  }, {\n    key: \"nodeToSpeech\",\n    value: function nodeToSpeech(event) {\n      // TODO: Update this if we link to the current version of blockly.\n      if (event.type === blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.Events.MARKER_MOVE) {\n        var nodeText = this.nodeToText_(event.newNode, event.oldNode, !event.isCursor);\n\n        if (!event.isCursor) {\n          nodeText = \"You have marked a location. To find a new block to connect\\n        to this location hit T. ! . To insert a block on the workspace,\\n        find the location of the block and hit I. \";\n        }\n\n        this.speak(nodeText, true);\n      }\n    }\n    /**\n     * Speaks out the text for a modal.\n     * @param {Element} modal The modal to collect the text to read out.\n     * @public\n     */\n\n  }, {\n    key: \"modalToText\",\n    value: function modalToText(modal) {\n      var header = modal.querySelector('header');\n      var headerText = header.textContent.trim();\n\n      if (headerText !== '') {\n        this.speak(headerText);\n      }\n\n      this.addButtonListeners_(header.querySelectorAll('button'));\n      var mainText = modal.querySelector('main').textContent.trim();\n\n      if (mainText !== '') {\n        this.speak(mainText);\n      }\n\n      var footerBtns = modal.querySelector('footer').querySelectorAll('button');\n      this.addButtonListeners_(footerBtns);\n    }\n    /**\n     * Adds listeners for when the button is focused.\n     * @param {!NodeList} btns The buttons to add listeners to.\n     * @private\n     */\n\n  }, {\n    key: \"addButtonListeners_\",\n    value: function addButtonListeners_(btns) {\n      var _this = this;\n\n      var _iterator = _createForOfIteratorHelper(btns),\n          _step;\n\n      try {\n        var _loop = function _loop() {\n          var btn = _step.value;\n          btn.addEventListener('focus', function () {\n            _this.buttonToSpeech_(btns, btn, true);\n          });\n\n          if (document.activeElement === btn) {\n            _this.buttonToSpeech_(btns, btn, false);\n          }\n        };\n\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    /**\n     * Speaks out information about a button.\n     * @param {NodeList} btns The list of buttons on the modal.\n     * @param {Element} btn The button.\n     * @param {boolean} shouldCancel True if this should cancel the previous\n     *     utterance.\n     * @private\n     */\n\n  }, {\n    key: \"buttonToSpeech_\",\n    value: function buttonToSpeech_(btns, btn, shouldCancel) {\n      this.speak('Hit enter to ', shouldCancel);\n\n      if (btn.textContent === '') {\n        this.speak(btn.getAttribute('aria-label'));\n      } else {\n        this.speak(btn.textContent);\n      }\n\n      if (btns.length > 0) {\n        this.speak('Hit tab to go to your next option');\n      }\n    }\n    /**\n     * Speaks out an audio representation of the given node.\n     * @param {Blockly.ASTNode} node The node to speak out.\n     * @param {Blockly.ASTNode} oldNode The previous node to speak out.\n     * @param {boolean} isMarker True to get the text for a marker,\n     *     false otherwise.\n     * @return {string} The text representation of the node.\n     * @public\n     */\n\n  }, {\n    key: \"nodeToText_\",\n    value: function nodeToText_(node, oldNode, isMarker) {\n      var finalText = '';\n\n      switch (node.getType()) {\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.FIELD:\n          finalText = this.fieldNodeToText_(node);\n          break;\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.BLOCK:\n          finalText = this.blockNodeToText_(node);\n          break;\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.INPUT:\n          finalText = this.inputNodeToText_(node, isMarker);\n          break;\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.OUTPUT:\n          finalText = this.outputNodeToText_(node, isMarker);\n          break;\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.NEXT:\n          finalText = this.nextNodeToText_(node, isMarker);\n          break;\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.PREVIOUS:\n          finalText = this.previousNodeToText_(node, isMarker);\n          break;\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.STACK:\n          finalText = this.stackNodeToText_(node, oldNode);\n          break;\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.WORKSPACE:\n          finalText = this.workspaceNodeToText_(node);\n          break;\n\n        default:\n          return node.toString();\n      }\n\n      finalText += this.getNextOptions_(node, oldNode, isMarker);\n      return finalText;\n    }\n    /**\n     * Gets text explaining the next options available for a user.\n     * @param {!Blockly.ASTNode} node The current node.\n     * @param {!Blockly.ASTNode} oldNode The previous node.\n     * @param {boolean} isMarker True if the marker was moved.\n     * @return {string} Text explaining next options for the field.\n     * @private\n     */\n\n  }, {\n    key: \"getNextOptions_\",\n    value: function getNextOptions_(node, oldNode, isMarker) {\n      switch (node.getType()) {\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.FIELD:\n          return this.getFieldOptions_(node);\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.BLOCK:\n          return this.getBlockOptions_(node);\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.INPUT:\n          return this.getConnectionOptions_(node, isMarker);\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.OUTPUT:\n          return this.getConnectionOptions_(node, isMarker);\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.NEXT:\n          return this.getConnectionOptions_(node, isMarker);\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.PREVIOUS:\n          return this.getConnectionOptions_(node, isMarker);\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.STACK:\n          return this.getStackOptions_(node);\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.WORKSPACE:\n          return '';\n\n        default:\n          return node.toString();\n      }\n    }\n    /**\n     * Gets the next options for when a user is on a field.\n     * This is to open the field or to change locations.\n     * @param {!Blockly.ASTNode} node The field node.\n     * @return {string} The text explaining the next options when a user is on a\n     *     field.\n     * @private\n     */\n\n  }, {\n    key: \"getFieldOptions_\",\n    value: function getFieldOptions_(node) {\n      var field = node.getLocation();\n\n      if (field.isClickable()) {\n        return \"To interact with the field hit enter. Use the next or previous\\n      keys to change locations. \";\n      } else {\n        return 'Use the next or previous keys to change locations. ';\n      }\n    }\n    /**\n     * Gets the next options for when a user is on a block.\n     * @return {string} The text explaining the next options for a block.\n     * @private\n     */\n\n  }, {\n    key: \"getBlockOptions_\",\n    value: function getBlockOptions_() {\n      return \"Use the next or previous keys to change locations. \";\n    }\n    /**\n     * Gets the text for the connection point.\n     * @param {!Blockly.ASTNode} node The connection node.\n     * @param {boolean} isMarker True if the marker was moved.\n     * @return {string} The text explaining the next options when a user is on a\n     *     connection.\n     * @private\n     */\n\n  }, {\n    key: \"getConnectionOptions_\",\n    value: function getConnectionOptions_(node, isMarker) {\n      var markerText = \". To mark this location, hit enter.\\n    To change locations use the next or previous keys\";\n      var finalText = '';\n\n      if (!isMarker) {\n        finalText += \"\".concat(markerText);\n      }\n\n      return finalText;\n    }\n    /**\n     * Gets the options for a user on a  stack of blocks.\n     * @return {string} The text explaining the next options when a user is on a\n     *     stack of blocks.\n     * @private\n     */\n\n  }, {\n    key: \"getStackOptions_\",\n    value: function getStackOptions_(node) {\n      var finalText = '';\n\n      if (node.prev()) {\n        finalText += \"To go to the last block in the previous group of blocks,\\n      press previous.\";\n      }\n\n      finalText += \" To go to the first block in the stack hit next.\";\n      return finalText;\n    }\n    /**\n     * Get the text for the source block of the node.\n     * @param {!Blockly.BlockSvg} srcBlock The block to get the text for.\n     * @param {string=} opt_emptyToken The optional empty token.\n     * @return {string} The text describing the source block of the node.\n     * @private\n     */\n\n  }, {\n    key: \"getBlockText_\",\n    value: function getBlockText_(srcBlock, opt_emptyToken) {\n      var emptyToken = opt_emptyToken || blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.Msg['EMPTY_TOKEN'];\n\n      if (srcBlock) {\n        if (srcBlock.statementInputCount > 0) {\n          emptyToken = ' do blank ';\n        }\n\n        return srcBlock.toString(null, emptyToken);\n      } else {\n        return '';\n      }\n    }\n    /**\n     * Creates text for a feild.\n     * @param {!Blockly.ASTNode} node The node to create text for.\n     * @return {string} The text for the screen reader to read out.\n     * @protected\n     */\n\n  }, {\n    key: \"fieldNodeToText_\",\n    value: function fieldNodeToText_(node) {\n      var field = node.getLocation();\n      return field.getText() + '. ';\n    }\n    /**\n     * Creates text for a feild.\n     * @param {!Blockly.ASTNode} node The node to create text for.\n     * @return {string} The text for the screen reader to read out.\n     * @protected\n     */\n\n  }, {\n    key: \"blockNodeToText_\",\n    value: function blockNodeToText_(node) {\n      var block =\n      /** @type{Blockly.BlockSvg} */\n      node.getLocation();\n      var blockText = this.getBlockText_(block);\n      var finalText = '';\n\n      if (block.getSurroundParent()) {\n        var parentBlockText = this.getBlockText_(block.getSurroundParent());\n        finalText += \"You are inside of block \".concat(parentBlockText, \". . \");\n      }\n\n      finalText += \"You are on , \".concat(blockText, \". . \");\n      return finalText;\n    }\n    /**\n     * Creates text for an input.\n     * @param {!Blockly.ASTNode} node The node to create text for.\n     * @param {boolean} isMarker True if the marker was moved.\n     * @return {string} The text for the screen reader to read out.\n     * @protected\n     */\n\n  }, {\n    key: \"inputNodeToText_\",\n    value: function inputNodeToText_(node, isMarker) {\n      var inputConnection =\n      /** @type{Blockly.Input} */\n      node.getLocation();\n      var connectionText = \"You are on a connection\";\n      var finalText = '';\n\n      if (inputConnection.type === blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.NEXT_STATEMENT) {\n        var blockText = this.getBlockText_(node.getSourceBlock());\n        finalText = \"Inside \".concat(blockText, \". \").concat(connectionText, \". \");\n      } else if (inputConnection.type === blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.INPUT_VALUE) {\n        var _blockText = this.getBlockText_(node.getSourceBlock(), ' ');\n\n        finalText = \"\".concat(connectionText, \" after \").concat(_blockText);\n      }\n\n      return finalText;\n    }\n    /**\n     * Creates text for a output connection.\n     * @param {!Blockly.ASTNode} node The node to create text for.\n     * @return {string} The text for the screen reader to read out.\n     * @protected\n     */\n\n  }, {\n    key: \"outputNodeToText_\",\n    value: function outputNodeToText_(node) {\n      var blockText = this.getBlockText_(node.getSourceBlock());\n      return \"You are on a connection for block, \".concat(blockText);\n    }\n    /**\n     * Creates text for a next connection.\n     * @param {!Blockly.ASTNode} node The node to create text for.\n     * @param {boolean} isMarker True to get the text for a marker,\n     *     false otherwise.\n     * @return {string} The text for the screen reader to read out.\n     * @protected\n     */\n\n  }, {\n    key: \"nextNodeToText_\",\n    value: function nextNodeToText_(node, isMarker) {\n      var block = node.getSourceBlock();\n      var blockText = this.getBlockText_(node.getSourceBlock());\n      var finalText = '';\n\n      if (block.getSurroundParent()) {\n        var parentBlockText = this.getBlockText_(block.getSurroundParent());\n        finalText += \"You are inside of block \".concat(parentBlockText, \". . \");\n      }\n\n      finalText += \"\".concat(blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.Msg['NEXT'], \" \").concat(blockText);\n      return finalText;\n    }\n    /**\n     * Creates text for a previous connection.\n     * @param {!Blockly.ASTNode} node The node to create text for.\n     * @param {boolean} isMarker True to get the text for a marker,\n     *     false otherwise.\n     * @return {string} The text for the screen reader to read out.\n     * @protected\n     */\n\n  }, {\n    key: \"previousNodeToText_\",\n    value: function previousNodeToText_(node, isMarker) {\n      var block = node.getSourceBlock();\n      var blockText = this.getBlockText_(block);\n      var finalText = '';\n\n      if (block.getSurroundParent()) {\n        var parentBlockText = this.getBlockText_(block.getSurroundParent());\n        finalText += \"You are inside of block \".concat(parentBlockText, \". . \");\n      }\n\n      finalText += \"\".concat(blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.Msg['PREVIOUS'], \" \").concat(blockText);\n      return finalText;\n    }\n    /**\n     * Creates text for a stack of blocks.\n     * @param {!Blockly.ASTNode} node The node to create text for.\n     * @param {!Blockly.ASTNode} oldNode The previous node.\n     * @return {string} The text for the screen reader to read out.\n     * @protected\n     */\n\n  }, {\n    key: \"stackNodeToText_\",\n    value: function stackNodeToText_(node, oldNode) {\n      var srcBlock = node.getSourceBlock();\n      var newNodeTopBlock = srcBlock.getTopStackBlock();\n      var oldNodeTopBlock = null;\n\n      if (oldNode && oldNode.getSourceBlock()) {\n        oldNodeTopBlock = oldNode.getSourceBlock().getTopStackBlock();\n      }\n\n      var finalText = '';\n\n      if (srcBlock && srcBlock.workspace.isFlyout) {\n        finalText = this.getBlockText_(node.getSourceBlock());\n        finalText += \" . . To add this block to the workspace press Enter. .\\n      To go to the next block hit next. . To go back to the workspace\\n      hit escape. \";\n      } else if (srcBlock) {\n        if (oldNodeTopBlock !== newNodeTopBlock) {\n          finalText += \"You are on a new group of blocks. \";\n        } else {\n          finalText += \"You are on a group of blocks. \";\n        }\n      }\n\n      return finalText;\n    }\n    /**\n     * Creates text for a workspace.\n     * @param {!Blockly.ASTNode} node The node to create text for.\n     * @return {string} The text for the screen reader to read out.\n     * @protected\n     */\n\n  }, {\n    key: \"workspaceNodeToText_\",\n    value: function workspaceNodeToText_(node) {\n      var workspace =\n      /** @type{Blockly.WorkspaceSvg} */\n      node.getLocation(); // TODO: All text should be added to Blockly.Msg to allow for translation.\n\n      var text = null;\n\n      if (workspace.isFlyout) {\n        text = 'In the flyout, please select a block';\n      } else if (workspace.isMutator) {\n        text = 'In the mutator workspace, use this workspace to change a block';\n      } else {\n        text = blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.Msg['MAIN_WS'];\n      }\n\n      return text;\n    }\n  }]);\n\n  return Speaker;\n}();\nvar speaker = new Speaker();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3BlYWtlci5qcz9jZDc3Il0sIm5hbWVzIjpbIlNwZWFrZXIiLCJvcHRNZXNzYWdlcyIsIm1lc3NhZ2VzIiwiQmxvY2tseSIsInV0aWxzIiwib2JqZWN0IiwibWl4aW4iLCJzZXRMb2NhbGUiLCJub092ZXJyaWRlcyIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwiayIsIk1zZyIsInRleHQiLCJzaG91bGRDYW5jZWwiLCJvbkVuZCIsIm9uU3RhcnQiLCJhdWRpbyIsIlNwZWVjaFN5bnRoZXNpc1V0dGVyYW5jZSIsIndpbmRvdyIsInNwZWVjaFN5bnRoZXNpcyIsInNwZWFraW5nIiwiY2FuY2VsIiwib25lbmQiLCJvbnN0YXJ0Iiwic3BlYWsiLCJwYXVzZSIsInJlc3VtZSIsImV2ZW50IiwidHlwZSIsIkV2ZW50cyIsIk1BUktFUl9NT1ZFIiwibm9kZVRleHQiLCJub2RlVG9UZXh0XyIsIm5ld05vZGUiLCJvbGROb2RlIiwiaXNDdXJzb3IiLCJtb2RhbCIsImhlYWRlciIsInF1ZXJ5U2VsZWN0b3IiLCJoZWFkZXJUZXh0IiwidGV4dENvbnRlbnQiLCJ0cmltIiwiYWRkQnV0dG9uTGlzdGVuZXJzXyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJtYWluVGV4dCIsImZvb3RlckJ0bnMiLCJidG5zIiwiYnRuIiwiYWRkRXZlbnRMaXN0ZW5lciIsImJ1dHRvblRvU3BlZWNoXyIsImRvY3VtZW50IiwiYWN0aXZlRWxlbWVudCIsImdldEF0dHJpYnV0ZSIsImxlbmd0aCIsIm5vZGUiLCJpc01hcmtlciIsImZpbmFsVGV4dCIsImdldFR5cGUiLCJBU1ROb2RlIiwidHlwZXMiLCJGSUVMRCIsImZpZWxkTm9kZVRvVGV4dF8iLCJCTE9DSyIsImJsb2NrTm9kZVRvVGV4dF8iLCJJTlBVVCIsImlucHV0Tm9kZVRvVGV4dF8iLCJPVVRQVVQiLCJvdXRwdXROb2RlVG9UZXh0XyIsIk5FWFQiLCJuZXh0Tm9kZVRvVGV4dF8iLCJQUkVWSU9VUyIsInByZXZpb3VzTm9kZVRvVGV4dF8iLCJTVEFDSyIsInN0YWNrTm9kZVRvVGV4dF8iLCJXT1JLU1BBQ0UiLCJ3b3Jrc3BhY2VOb2RlVG9UZXh0XyIsInRvU3RyaW5nIiwiZ2V0TmV4dE9wdGlvbnNfIiwiZ2V0RmllbGRPcHRpb25zXyIsImdldEJsb2NrT3B0aW9uc18iLCJnZXRDb25uZWN0aW9uT3B0aW9uc18iLCJnZXRTdGFja09wdGlvbnNfIiwiZmllbGQiLCJnZXRMb2NhdGlvbiIsImlzQ2xpY2thYmxlIiwibWFya2VyVGV4dCIsInByZXYiLCJzcmNCbG9jayIsIm9wdF9lbXB0eVRva2VuIiwiZW1wdHlUb2tlbiIsInN0YXRlbWVudElucHV0Q291bnQiLCJnZXRUZXh0IiwiYmxvY2siLCJibG9ja1RleHQiLCJnZXRCbG9ja1RleHRfIiwiZ2V0U3Vycm91bmRQYXJlbnQiLCJwYXJlbnRCbG9ja1RleHQiLCJpbnB1dENvbm5lY3Rpb24iLCJjb25uZWN0aW9uVGV4dCIsIk5FWFRfU1RBVEVNRU5UIiwiZ2V0U291cmNlQmxvY2siLCJJTlBVVF9WQUxVRSIsIm5ld05vZGVUb3BCbG9jayIsImdldFRvcFN0YWNrQmxvY2siLCJvbGROb2RlVG9wQmxvY2siLCJ3b3Jrc3BhY2UiLCJpc0ZseW91dCIsImlzTXV0YXRvciIsInNwZWFrZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ08sSUFBTUEsT0FBYjtBQUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0UsbUJBQVlDLFdBQVosRUFBeUI7QUFBQTs7QUFDdkIsUUFBTUMsUUFBUSxHQUFHO0FBQ2YsaUJBQVcsdUJBREk7QUFFZixlQUNJLG1FQUNBLDJEQUpXO0FBS2Ysa0JBQVksa0NBTEc7QUFNZixjQUFRLHlCQU5PO0FBT2YsZ0JBQVUsMkJBUEs7QUFRZixvQkFBYyx3QkFSQztBQVNmLGVBQVMsb0JBVE07QUFVZix5QkFBbUIs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QVMsR0FBRyxLQUFLc0MsYUFBTCxDQUFtQnhDLElBQUksQ0FBQzhDLGNBQUwsRUFBbkIsQ0FBWjtBQUNBNUMsaUJBQVMsdUpBQVQ7QUFHRCxPQUxELE1BS08sSUFBSStCLFFBQUosRUFBYztBQUNuQixZQUFJaUIsZUFBZSxLQUFLRixlQUF4QixFQUF5QztBQUN2QzlDLG1CQUFTLHdDQUFUO0FBQ0QsU0FGRCxNQUVPO0FBQ0xBLG1CQUFTLG9DQUFUO0FBQ0Q7QUFDRjs7QUFDRCxhQUFPQSxTQUFQO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBemRBO0FBQUE7QUFBQSx5Q0EwZHVCRixJQTFkdkIsRUEwZDZCO0FBQ3pCLFVBQU1tRCxTQUFTO0FBQUc7QUFBb0NuRCxVQUFJLENBQUM2QixXQUFMLEVBQXRELENBRHlCLENBRXpCOztBQUNBLFVBQUl2RSxJQUFJLEdBQUcsSUFBWDs7QUFDQSxVQUFJNkYsU0FBUyxDQUFDQyxRQUFkLEVBQXdCO0FBQ3RCOUYsWUFBSSxHQUFHLHNDQUFQO0FBQ0QsT0FGRCxNQUVPLElBQUk2RixTQUFTLENBQUNFLFNBQWQsRUFBeUI7QUFDOUIvRixZQUFJLEdBQUcsZ0VBQVA7QUFDRCxPQUZNLE1BRUE7QUFDTEEsWUFBSSxHQUFHWCxtREFBTyxDQUFDVSxHQUFSLENBQVksU0FBWixDQUFQO0FBQ0Q7O0FBQ0QsYUFBT0MsSUFBUDtBQUNEO0FBdGVIOztBQUFBO0FBQUE7QUF5ZU8sSUFBTWdHLE9BQU8sR0FBRyxJQUFJOUcsT0FBSixFQUFoQiIsImZpbGUiOiIuL3NyYy9zcGVha2VyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBTcGVha2VyIHVzZWQgZm9yIHNwZWFraW5nIG91dCB0ZXh0LlxuICovXG5cbmltcG9ydCBCbG9ja2x5IGZyb20gJ2Jsb2NrbHkvY29yZSc7XG5cbi8qKlxuICogQ29udmVuaWVuY2UgbWV0aG9kcyBmb3Igc3BlYWtpbmcgb3V0IHRleHQuXG4gKiBNb3JlIGluZm9ybWF0aW9uIG9uIHNwZWFrZXJzIGNhbiBiZSBmb3VuZCBoZXJlOlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NwZWVjaFN5bnRoZXNpcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFNwZWFrZXIge1xuICAvKipcbiAgICogQ29uc3RydWN0b3IgZm9yIGEgc3BlYWtlci5cbiAgICogQHBhcmFtIHtTcGVha2VyTWVzc2FnZXM9fSBvcHRNZXNzYWdlcyBPcHRpb25hbCBtZXNzYWdlcyBmb3IgdGhlIHNwZWFrZXIuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRNZXNzYWdlcykge1xuICAgIGNvbnN0IG1lc3NhZ2VzID0ge1xuICAgICAgJ01BSU5fV1MnOiAnT24gdGhlIG1haW4gd29ya3NwYWNlJyxcbiAgICAgICdTVEFDSyc6XG4gICAgICAgICAgJ1RvIGdvIHRvIHRoZSBsYXN0IGJsb2NrIGluIHRoZSBwcmV2aW91cyBncm91cCBvZiBibG9ja3MsIHByZXNzJyArXG4gICAgICAgICAgJ3ByZXZpb3VzLiBUbyBnbyB0byB0aGUgZmlyc3QgYmxvY2sgaW4gdGhlIHN0YWNrIGhpdCBuZXh0LicsXG4gICAgICAnUFJFVklPVVMnOiAnWW91IGFyZSBvbiBhIGNvbm5lY3Rpb24gYmVmb3JlLCAnLFxuICAgICAgJ05FWFQnOiAnT24gYSBjb25uZWN0aW9uIGFmdGVyLCAnLFxuICAgICAgJ09VVFBVVCc6ICdPbiBhbiBvdXRwdXQgY29ubmVjdGlvbi4gJyxcbiAgICAgICdDT05ORUNUSU9OJzogJ0F0IGEgY29ubmVjdGlvbiBwb2ludC4nLFxuICAgICAgJ0JMT0NLJzogJ09uIGEgYmxvY2sgb2YgdHlwZScsXG4gICAgICAnQ0xJQ0tBQkxFX0ZJRUxEJzogJ1RvIGludGVyYWN0IHdpdGggdGhlIGZpZWxkIGhpdCBlbnRlci4nLFxuICAgICAgJ0VNUFRZX1RPS0VOJzogJ2JsYW5rJyxcbiAgICAgICdNQVJLX0NPTk5FQ1RJT04nOiAnVG8gbWFyayB0aGUgYmxvY2sgcHJlc3MgZW50ZXIuICcsXG4gICAgICAnRVhJVF9FRElUX01PREUnOiAnVG8gZXhpdCBlZGl0IG1vZGUgaGl0IGVzY2FwZS4gJyxcbiAgICB9O1xuXG4gICAgQmxvY2tseS51dGlscy5vYmplY3QubWl4aW4obWVzc2FnZXMsIG9wdE1lc3NhZ2VzKTtcblxuICAgIHRoaXMuc2V0TG9jYWxlKG1lc3NhZ2VzKTtcbiAgICB0aGlzLm5vT3ZlcnJpZGVzID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogVGhlIG1lc3NhZ2VzIHRvIGJlIHJlYWQgb3V0IGJ5IGEgc2NyZWVuIHJlYWRlci5cbiAgICogQHR5cGVkZWYge3tcbiAgICogICAgIE1BSU5fV1M6IHN0cmluZyxcbiAgICogICAgIFNUQUNLOiBzdHJpbmcsXG4gICAqICAgICBQUkVWSU9VUzogc3RyaW5nLFxuICAgKiAgICAgTkVYVDogc3RyaW5nLFxuICAgKiAgICAgT1VUUFVUOiBzdHJpbmcsXG4gICAqICAgICBDT05ORUNUSU9OOiBzdHJpbmcsXG4gICAqICAgICBCTE9DSzogc3RyaW5nLFxuICAgKiAgICAgRU1QVFlfVE9LRU46IHN0cmluZyxcbiAgICogICAgIE1BUktfQ09OTkVDVElPTjogc3RyaW5nLFxuICAgKiB9fSBTcGVha2VyTWVzc2FnZXNcbiAgICovXG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbWVzc2FnZXMgZm9yIHRoZSBzcGVha2VyLlxuICAgKiBAcGFyYW0geyFTcGVha2VyTWVzc2FnZXN9IG1lc3NhZ2VzIFRoZSBtZXNzYWdlcyBuZWVkZWQgdG8gY3JlYXRlIGEgc3BlYWtlci5cbiAgICovXG4gIHNldExvY2FsZShtZXNzYWdlcykge1xuICAgIE9iamVjdC5rZXlzKG1lc3NhZ2VzKS5mb3JFYWNoKChrKSA9PiB7XG4gICAgICBCbG9ja2x5Lk1zZ1trXSA9IG1lc3NhZ2VzW2tdO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwZWFrcyBvdXQgdGhlIHRleHQgdGhhdCB3YXMgZ2l2ZW4gdG8gaXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIHNwZWFrIG91dC5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gc2hvdWxkQ2FuY2VsIFRydWUgdG8gc3RvcCB0aGUgY3VycmVudCB1dHRlcmFuY2UsIGZhbHNlIHRvXG4gICAqICAgICB3YWl0IHVudGlsIHRoZSBjdXJyZW50IHV0dGVyYW5jZSBpcyBkb25lIGJlZm9yZSBzcGVha2luZy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbj19IG9uRW5kIFRoZSBmdW5jdGlvbiB0byBydW4gYWZ0ZXIgdGhlIHRleHQgaGFzIGJlZW5cbiAgICogICAgIHNwb2tlbi5cbiAgICogQHBhcmFtIHtmdW5jdGlvbj19IG9uU3RhcnQgVGhlIGZ1bmN0aW9uIHJ1biB3aGVuIHRoZSB0ZXh0IGhhcyBiZWd1biB0b1xuICAgKiAgICAgYmUgc3Bva2VuLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBzcGVhayh0ZXh0LCBzaG91bGRDYW5jZWwsIG9uRW5kLCBvblN0YXJ0KSB7XG4gICAgY29uc3QgYXVkaW8gPSBuZXcgU3BlZWNoU3ludGhlc2lzVXR0ZXJhbmNlKHRleHQpO1xuXG4gICAgaWYgKHNob3VsZENhbmNlbCAmJiAhdGhpcy5ub092ZXJyaWRlcyAmJiB3aW5kb3cuc3BlZWNoU3ludGhlc2lzLnNwZWFraW5nKSB7XG4gICAgICB3aW5kb3cuc3BlZWNoU3ludGhlc2lzLmNhbmNlbCgpO1xuICAgIH1cblxuICAgIGlmIChvbkVuZCkge1xuICAgICAgYXVkaW8ub25lbmQgPSBvbkVuZDtcbiAgICB9XG5cbiAgICBpZiAob25TdGFydCkge1xuICAgICAgYXVkaW8ub25zdGFydCA9IG9uU3RhcnQ7XG4gICAgfVxuICAgIHdpbmRvdy5zcGVlY2hTeW50aGVzaXMuc3BlYWsoYXVkaW8pO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyBvdXQgdGhlIHF1ZXVlIG9mIHRleHQgdG8gc3BlYWsuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNhbmNlbCgpIHtcbiAgICB3aW5kb3cuc3BlZWNoU3ludGhlc2lzLmNhbmNlbCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdXNlcyBzcGVha2luZy5cbiAgICovXG4gIHBhdXNlKCkge1xuICAgIHdpbmRvdy5zcGVlY2hTeW50aGVzaXMucGF1c2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN1bWVzIHNwZWFraW5nLlxuICAgKi9cbiAgcmVzdW1lKCkge1xuICAgIHdpbmRvdy5zcGVlY2hTeW50aGVzaXMucmVzdW1lKCk7XG4gIH1cblxuICAvKipcbiAgICogU3BlYWtzIG91dCB0ZXh0IGlmIHRoZSBldmVudCBpcyBvZiB0eXBlIG1hcmtlciBvciBjdXJzb3IgbW92ZS5cbiAgICogQHBhcmFtIHshQmxvY2tseS5FdmVudHN9IGV2ZW50IFRoZSBldmVudCB0byBzcGVhayBvdXQuXG4gICAqL1xuICBub2RlVG9TcGVlY2goZXZlbnQpIHtcbiAgICAvLyBUT0RPOiBVcGRhdGUgdGhpcyBpZiB3ZSBsaW5rIHRvIHRoZSBjdXJyZW50IHZlcnNpb24gb2YgYmxvY2tseS5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gQmxvY2tseS5FdmVudHMuTUFSS0VSX01PVkUpIHtcbiAgICAgIGxldCBub2RlVGV4dCA9XG4gICAgICAgICAgdGhpcy5ub2RlVG9UZXh0XyhldmVudC5uZXdOb2RlLCBldmVudC5vbGROb2RlLCAhZXZlbnQuaXNDdXJzb3IpO1xuICAgICAgaWYgKCFldmVudC5pc0N1cnNvcikge1xuICAgICAgICBub2RlVGV4dCA9IGBZb3UgaGF2ZSBtYXJrZWQgYSBsb2NhdGlvbi4gVG8gZmluZCBhIG5ldyBibG9jayB0byBjb25uZWN0XG4gICAgICAgIHRvIHRoaXMgbG9jYXRpb24gaGl0IFQuICEgLiBUbyBpbnNlcnQgYSBibG9jayBvbiB0aGUgd29ya3NwYWNlLFxuICAgICAgICBmaW5kIHRoZSBsb2NhdGlvbiBvZiB0aGUgYmxvY2sgYW5kIGhpdCBJLiBgO1xuICAgICAgfVxuICAgICAgdGhpcy5zcGVhayhub2RlVGV4dCwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNwZWFrcyBvdXQgdGhlIHRleHQgZm9yIGEgbW9kYWwuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbW9kYWwgVGhlIG1vZGFsIHRvIGNvbGxlY3QgdGhlIHRleHQgdG8gcmVhZCBvdXQuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIG1vZGFsVG9UZXh0KG1vZGFsKSB7XG4gICAgY29uc3QgaGVhZGVyID0gbW9kYWwucXVlcnlTZWxlY3RvcignaGVhZGVyJyk7XG4gICAgY29uc3QgaGVhZGVyVGV4dCA9IGhlYWRlci50ZXh0Q29udGVudC50cmltKCk7XG4gICAgaWYgKGhlYWRlclRleHQgIT09ICcnKSB7XG4gICAgICB0aGlzLnNwZWFrKGhlYWRlclRleHQpO1xuICAgIH1cbiAgICB0aGlzLmFkZEJ1dHRvbkxpc3RlbmVyc18oaGVhZGVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ2J1dHRvbicpKTtcblxuICAgIGNvbnN0IG1haW5UZXh0ID0gbW9kYWwucXVlcnlTZWxlY3RvcignbWFpbicpLnRleHRDb250ZW50LnRyaW0oKTtcblxuICAgIGlmIChtYWluVGV4dCAhPT0gJycpIHtcbiAgICAgIHRoaXMuc3BlYWsobWFpblRleHQpO1xuICAgIH1cblxuICAgIGNvbnN0IGZvb3RlckJ0bnMgPSBtb2RhbC5xdWVyeVNlbGVjdG9yKCdmb290ZXInKS5xdWVyeVNlbGVjdG9yQWxsKCdidXR0b24nKTtcbiAgICB0aGlzLmFkZEJ1dHRvbkxpc3RlbmVyc18oZm9vdGVyQnRucyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBsaXN0ZW5lcnMgZm9yIHdoZW4gdGhlIGJ1dHRvbiBpcyBmb2N1c2VkLlxuICAgKiBAcGFyYW0geyFOb2RlTGlzdH0gYnRucyBUaGUgYnV0dG9ucyB0byBhZGQgbGlzdGVuZXJzIHRvLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWRkQnV0dG9uTGlzdGVuZXJzXyhidG5zKSB7XG4gICAgZm9yIChjb25zdCBidG4gb2YgYnRucykge1xuICAgICAgYnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgKCkgPT4ge1xuICAgICAgICB0aGlzLmJ1dHRvblRvU3BlZWNoXyhidG5zLCBidG4sIHRydWUpO1xuICAgICAgfSk7XG4gICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gYnRuKSB7XG4gICAgICAgIHRoaXMuYnV0dG9uVG9TcGVlY2hfKGJ0bnMsIGJ0biwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTcGVha3Mgb3V0IGluZm9ybWF0aW9uIGFib3V0IGEgYnV0dG9uLlxuICAgKiBAcGFyYW0ge05vZGVMaXN0fSBidG5zIFRoZSBsaXN0IG9mIGJ1dHRvbnMgb24gdGhlIG1vZGFsLlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGJ0biBUaGUgYnV0dG9uLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZENhbmNlbCBUcnVlIGlmIHRoaXMgc2hvdWxkIGNhbmNlbCB0aGUgcHJldmlvdXNcbiAgICogICAgIHV0dGVyYW5jZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGJ1dHRvblRvU3BlZWNoXyhidG5zLCBidG4sIHNob3VsZENhbmNlbCkge1xuICAgIHRoaXMuc3BlYWsoJ0hpdCBlbnRlciB0byAnLCBzaG91bGRDYW5jZWwpO1xuICAgIGlmIChidG4udGV4dENvbnRlbnQgPT09ICcnKSB7XG4gICAgICB0aGlzLnNwZWFrKGJ0bi5nZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3BlYWsoYnRuLnRleHRDb250ZW50KTtcbiAgICB9XG4gICAgaWYgKGJ0bnMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5zcGVhaygnSGl0IHRhYiB0byBnbyB0byB5b3VyIG5leHQgb3B0aW9uJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNwZWFrcyBvdXQgYW4gYXVkaW8gcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIG5vZGUuXG4gICAqIEBwYXJhbSB7QmxvY2tseS5BU1ROb2RlfSBub2RlIFRoZSBub2RlIHRvIHNwZWFrIG91dC5cbiAgICogQHBhcmFtIHtCbG9ja2x5LkFTVE5vZGV9IG9sZE5vZGUgVGhlIHByZXZpb3VzIG5vZGUgdG8gc3BlYWsgb3V0LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTWFya2VyIFRydWUgdG8gZ2V0IHRoZSB0ZXh0IGZvciBhIG1hcmtlcixcbiAgICogICAgIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgdGV4dCByZXByZXNlbnRhdGlvbiBvZiB0aGUgbm9kZS5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgbm9kZVRvVGV4dF8obm9kZSwgb2xkTm9kZSwgaXNNYXJrZXIpIHtcbiAgICBsZXQgZmluYWxUZXh0ID0gJyc7XG4gICAgc3dpdGNoIChub2RlLmdldFR5cGUoKSkge1xuICAgICAgY2FzZSBCbG9ja2x5LkFTVE5vZGUudHlwZXMuRklFTEQ6XG4gICAgICAgIGZpbmFsVGV4dCA9IHRoaXMuZmllbGROb2RlVG9UZXh0Xyhub2RlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEJsb2NrbHkuQVNUTm9kZS50eXBlcy5CTE9DSzpcbiAgICAgICAgZmluYWxUZXh0ID0gdGhpcy5ibG9ja05vZGVUb1RleHRfKG5vZGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQmxvY2tseS5BU1ROb2RlLnR5cGVzLklOUFVUOlxuICAgICAgICBmaW5hbFRleHQgPSB0aGlzLmlucHV0Tm9kZVRvVGV4dF8obm9kZSwgaXNNYXJrZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQmxvY2tseS5BU1ROb2RlLnR5cGVzLk9VVFBVVDpcbiAgICAgICAgZmluYWxUZXh0ID0gdGhpcy5vdXRwdXROb2RlVG9UZXh0Xyhub2RlLCBpc01hcmtlcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBCbG9ja2x5LkFTVE5vZGUudHlwZXMuTkVYVDpcbiAgICAgICAgZmluYWxUZXh0ID0gdGhpcy5uZXh0Tm9kZVRvVGV4dF8obm9kZSwgaXNNYXJrZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQmxvY2tseS5BU1ROb2RlLnR5cGVzLlBSRVZJT1VTOlxuICAgICAgICBmaW5hbFRleHQgPSB0aGlzLnByZXZpb3VzTm9kZVRvVGV4dF8obm9kZSwgaXNNYXJrZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQmxvY2tseS5BU1ROb2RlLnR5cGVzLlNUQUNLOlxuICAgICAgICBmaW5hbFRleHQgPSB0aGlzLnN0YWNrTm9kZVRvVGV4dF8obm9kZSwgb2xkTm9kZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBCbG9ja2x5LkFTVE5vZGUudHlwZXMuV09SS1NQQUNFOlxuICAgICAgICBmaW5hbFRleHQgPSB0aGlzLndvcmtzcGFjZU5vZGVUb1RleHRfKG5vZGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBub2RlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGZpbmFsVGV4dCArPSB0aGlzLmdldE5leHRPcHRpb25zXyhub2RlLCBvbGROb2RlLCBpc01hcmtlcik7XG4gICAgcmV0dXJuIGZpbmFsVGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRleHQgZXhwbGFpbmluZyB0aGUgbmV4dCBvcHRpb25zIGF2YWlsYWJsZSBmb3IgYSB1c2VyLlxuICAgKiBAcGFyYW0geyFCbG9ja2x5LkFTVE5vZGV9IG5vZGUgVGhlIGN1cnJlbnQgbm9kZS5cbiAgICogQHBhcmFtIHshQmxvY2tseS5BU1ROb2RlfSBvbGROb2RlIFRoZSBwcmV2aW91cyBub2RlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTWFya2VyIFRydWUgaWYgdGhlIG1hcmtlciB3YXMgbW92ZWQuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGV4dCBleHBsYWluaW5nIG5leHQgb3B0aW9ucyBmb3IgdGhlIGZpZWxkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0TmV4dE9wdGlvbnNfKG5vZGUsIG9sZE5vZGUsIGlzTWFya2VyKSB7XG4gICAgc3dpdGNoIChub2RlLmdldFR5cGUoKSkge1xuICAgICAgY2FzZSBCbG9ja2x5LkFTVE5vZGUudHlwZXMuRklFTEQ6XG4gICAgICAgIHJldHVybiB0aGlzLmdldEZpZWxkT3B0aW9uc18obm9kZSk7XG4gICAgICBjYXNlIEJsb2NrbHkuQVNUTm9kZS50eXBlcy5CTE9DSzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmxvY2tPcHRpb25zXyhub2RlKTtcbiAgICAgIGNhc2UgQmxvY2tseS5BU1ROb2RlLnR5cGVzLklOUFVUOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb25uZWN0aW9uT3B0aW9uc18obm9kZSwgaXNNYXJrZXIpO1xuICAgICAgY2FzZSBCbG9ja2x5LkFTVE5vZGUudHlwZXMuT1VUUFVUOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb25uZWN0aW9uT3B0aW9uc18obm9kZSwgaXNNYXJrZXIpO1xuICAgICAgY2FzZSBCbG9ja2x5LkFTVE5vZGUudHlwZXMuTkVYVDpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29ubmVjdGlvbk9wdGlvbnNfKG5vZGUsIGlzTWFya2VyKTtcbiAgICAgIGNhc2UgQmxvY2tseS5BU1ROb2RlLnR5cGVzLlBSRVZJT1VTOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb25uZWN0aW9uT3B0aW9uc18obm9kZSwgaXNNYXJrZXIpO1xuICAgICAgY2FzZSBCbG9ja2x5LkFTVE5vZGUudHlwZXMuU1RBQ0s6XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0YWNrT3B0aW9uc18obm9kZSk7XG4gICAgICBjYXNlIEJsb2NrbHkuQVNUTm9kZS50eXBlcy5XT1JLU1BBQ0U6XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBub2RlLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG5leHQgb3B0aW9ucyBmb3Igd2hlbiBhIHVzZXIgaXMgb24gYSBmaWVsZC5cbiAgICogVGhpcyBpcyB0byBvcGVuIHRoZSBmaWVsZCBvciB0byBjaGFuZ2UgbG9jYXRpb25zLlxuICAgKiBAcGFyYW0geyFCbG9ja2x5LkFTVE5vZGV9IG5vZGUgVGhlIGZpZWxkIG5vZGUuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHRleHQgZXhwbGFpbmluZyB0aGUgbmV4dCBvcHRpb25zIHdoZW4gYSB1c2VyIGlzIG9uIGFcbiAgICogICAgIGZpZWxkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0RmllbGRPcHRpb25zXyhub2RlKSB7XG4gICAgY29uc3QgZmllbGQgPSBub2RlLmdldExvY2F0aW9uKCk7XG4gICAgaWYgKGZpZWxkLmlzQ2xpY2thYmxlKCkpIHtcbiAgICAgIHJldHVybiBgVG8gaW50ZXJhY3Qgd2l0aCB0aGUgZmllbGQgaGl0IGVudGVyLiBVc2UgdGhlIG5leHQgb3IgcHJldmlvdXNcbiAgICAgIGtleXMgdG8gY2hhbmdlIGxvY2F0aW9ucy4gYDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICdVc2UgdGhlIG5leHQgb3IgcHJldmlvdXMga2V5cyB0byBjaGFuZ2UgbG9jYXRpb25zLiAnO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBuZXh0IG9wdGlvbnMgZm9yIHdoZW4gYSB1c2VyIGlzIG9uIGEgYmxvY2suXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHRleHQgZXhwbGFpbmluZyB0aGUgbmV4dCBvcHRpb25zIGZvciBhIGJsb2NrLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0QmxvY2tPcHRpb25zXygpIHtcbiAgICByZXR1cm4gYFVzZSB0aGUgbmV4dCBvciBwcmV2aW91cyBrZXlzIHRvIGNoYW5nZSBsb2NhdGlvbnMuIGA7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdGV4dCBmb3IgdGhlIGNvbm5lY3Rpb24gcG9pbnQuXG4gICAqIEBwYXJhbSB7IUJsb2NrbHkuQVNUTm9kZX0gbm9kZSBUaGUgY29ubmVjdGlvbiBub2RlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTWFya2VyIFRydWUgaWYgdGhlIG1hcmtlciB3YXMgbW92ZWQuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHRleHQgZXhwbGFpbmluZyB0aGUgbmV4dCBvcHRpb25zIHdoZW4gYSB1c2VyIGlzIG9uIGFcbiAgICogICAgIGNvbm5lY3Rpb24uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRDb25uZWN0aW9uT3B0aW9uc18obm9kZSwgaXNNYXJrZXIpIHtcbiAgICBjb25zdCBtYXJrZXJUZXh0ID0gYC4gVG8gbWFyayB0aGlzIGxvY2F0aW9uLCBoaXQgZW50ZXIuXG4gICAgVG8gY2hhbmdlIGxvY2F0aW9ucyB1c2UgdGhlIG5leHQgb3IgcHJldmlvdXMga2V5c2A7XG4gICAgbGV0IGZpbmFsVGV4dCA9ICcnO1xuICAgIGlmICghaXNNYXJrZXIpIHtcbiAgICAgIGZpbmFsVGV4dCArPSBgJHttYXJrZXJUZXh0fWA7XG4gICAgfVxuICAgIHJldHVybiBmaW5hbFRleHQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgb3B0aW9ucyBmb3IgYSB1c2VyIG9uIGEgIHN0YWNrIG9mIGJsb2Nrcy5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgdGV4dCBleHBsYWluaW5nIHRoZSBuZXh0IG9wdGlvbnMgd2hlbiBhIHVzZXIgaXMgb24gYVxuICAgKiAgICAgc3RhY2sgb2YgYmxvY2tzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0U3RhY2tPcHRpb25zXyhub2RlKSB7XG4gICAgbGV0IGZpbmFsVGV4dCA9ICcnO1xuICAgIGlmIChub2RlLnByZXYoKSkge1xuICAgICAgZmluYWxUZXh0ICs9IGBUbyBnbyB0byB0aGUgbGFzdCBibG9jayBpbiB0aGUgcHJldmlvdXMgZ3JvdXAgb2YgYmxvY2tzLFxuICAgICAgcHJlc3MgcHJldmlvdXMuYDtcbiAgICB9XG4gICAgZmluYWxUZXh0ICs9IGAgVG8gZ28gdG8gdGhlIGZpcnN0IGJsb2NrIGluIHRoZSBzdGFjayBoaXQgbmV4dC5gO1xuICAgIHJldHVybiBmaW5hbFRleHQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0ZXh0IGZvciB0aGUgc291cmNlIGJsb2NrIG9mIHRoZSBub2RlLlxuICAgKiBAcGFyYW0geyFCbG9ja2x5LkJsb2NrU3ZnfSBzcmNCbG9jayBUaGUgYmxvY2sgdG8gZ2V0IHRoZSB0ZXh0IGZvci5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfZW1wdHlUb2tlbiBUaGUgb3B0aW9uYWwgZW1wdHkgdG9rZW4uXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHRleHQgZGVzY3JpYmluZyB0aGUgc291cmNlIGJsb2NrIG9mIHRoZSBub2RlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0QmxvY2tUZXh0XyhzcmNCbG9jaywgb3B0X2VtcHR5VG9rZW4pIHtcbiAgICBsZXQgZW1wdHlUb2tlbiA9IG9wdF9lbXB0eVRva2VuIHx8IEJsb2NrbHkuTXNnWydFTVBUWV9UT0tFTiddO1xuICAgIGlmIChzcmNCbG9jaykge1xuICAgICAgaWYgKHNyY0Jsb2NrLnN0YXRlbWVudElucHV0Q291bnQgPiAwKSB7XG4gICAgICAgIGVtcHR5VG9rZW4gPSAnIGRvIGJsYW5rICc7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3JjQmxvY2sudG9TdHJpbmcobnVsbCwgZW1wdHlUb2tlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyB0ZXh0IGZvciBhIGZlaWxkLlxuICAgKiBAcGFyYW0geyFCbG9ja2x5LkFTVE5vZGV9IG5vZGUgVGhlIG5vZGUgdG8gY3JlYXRlIHRleHQgZm9yLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB0ZXh0IGZvciB0aGUgc2NyZWVuIHJlYWRlciB0byByZWFkIG91dC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZmllbGROb2RlVG9UZXh0Xyhub2RlKSB7XG4gICAgY29uc3QgZmllbGQgPSBub2RlLmdldExvY2F0aW9uKCk7XG4gICAgcmV0dXJuIGZpZWxkLmdldFRleHQoKSArICcuICc7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyB0ZXh0IGZvciBhIGZlaWxkLlxuICAgKiBAcGFyYW0geyFCbG9ja2x5LkFTVE5vZGV9IG5vZGUgVGhlIG5vZGUgdG8gY3JlYXRlIHRleHQgZm9yLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB0ZXh0IGZvciB0aGUgc2NyZWVuIHJlYWRlciB0byByZWFkIG91dC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgYmxvY2tOb2RlVG9UZXh0Xyhub2RlKSB7XG4gICAgY29uc3QgYmxvY2sgPSAvKiogQHR5cGV7QmxvY2tseS5CbG9ja1N2Z30gKi8gKG5vZGUuZ2V0TG9jYXRpb24oKSk7XG4gICAgY29uc3QgYmxvY2tUZXh0ID0gdGhpcy5nZXRCbG9ja1RleHRfKGJsb2NrKTtcbiAgICBsZXQgZmluYWxUZXh0ID0gJyc7XG4gICAgaWYgKGJsb2NrLmdldFN1cnJvdW5kUGFyZW50KCkpIHtcbiAgICAgIGNvbnN0IHBhcmVudEJsb2NrVGV4dCA9IHRoaXMuZ2V0QmxvY2tUZXh0XyhibG9jay5nZXRTdXJyb3VuZFBhcmVudCgpKTtcbiAgICAgIGZpbmFsVGV4dCArPSBgWW91IGFyZSBpbnNpZGUgb2YgYmxvY2sgJHtwYXJlbnRCbG9ja1RleHR9LiAuIGA7XG4gICAgfVxuICAgIGZpbmFsVGV4dCArPSBgWW91IGFyZSBvbiAsICR7YmxvY2tUZXh0fS4gLiBgO1xuICAgIHJldHVybiBmaW5hbFRleHQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyB0ZXh0IGZvciBhbiBpbnB1dC5cbiAgICogQHBhcmFtIHshQmxvY2tseS5BU1ROb2RlfSBub2RlIFRoZSBub2RlIHRvIGNyZWF0ZSB0ZXh0IGZvci5cbiAgICogQHBhcmFtIHtib29sZWFufSBpc01hcmtlciBUcnVlIGlmIHRoZSBtYXJrZXIgd2FzIG1vdmVkLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB0ZXh0IGZvciB0aGUgc2NyZWVuIHJlYWRlciB0byByZWFkIG91dC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgaW5wdXROb2RlVG9UZXh0Xyhub2RlLCBpc01hcmtlcikge1xuICAgIGNvbnN0IGlucHV0Q29ubmVjdGlvbiA9IC8qKiBAdHlwZXtCbG9ja2x5LklucHV0fSAqLyAobm9kZS5nZXRMb2NhdGlvbigpKTtcbiAgICBjb25zdCBjb25uZWN0aW9uVGV4dCA9IGBZb3UgYXJlIG9uIGEgY29ubmVjdGlvbmA7XG4gICAgbGV0IGZpbmFsVGV4dCA9ICcnO1xuICAgIGlmIChpbnB1dENvbm5lY3Rpb24udHlwZSA9PT0gQmxvY2tseS5ORVhUX1NUQVRFTUVOVCkge1xuICAgICAgY29uc3QgYmxvY2tUZXh0ID0gdGhpcy5nZXRCbG9ja1RleHRfKG5vZGUuZ2V0U291cmNlQmxvY2soKSk7XG4gICAgICBmaW5hbFRleHQgPSBgSW5zaWRlICR7YmxvY2tUZXh0fS4gJHtjb25uZWN0aW9uVGV4dH0uIGA7XG4gICAgfSBlbHNlIGlmIChpbnB1dENvbm5lY3Rpb24udHlwZSA9PT0gQmxvY2tseS5JTlBVVF9WQUxVRSkge1xuICAgICAgY29uc3QgYmxvY2tUZXh0ID0gdGhpcy5nZXRCbG9ja1RleHRfKG5vZGUuZ2V0U291cmNlQmxvY2soKSwgJyAnKTtcbiAgICAgIGZpbmFsVGV4dCA9IGAke2Nvbm5lY3Rpb25UZXh0fSBhZnRlciAke2Jsb2NrVGV4dH1gO1xuICAgIH1cbiAgICByZXR1cm4gZmluYWxUZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGV4dCBmb3IgYSBvdXRwdXQgY29ubmVjdGlvbi5cbiAgICogQHBhcmFtIHshQmxvY2tseS5BU1ROb2RlfSBub2RlIFRoZSBub2RlIHRvIGNyZWF0ZSB0ZXh0IGZvci5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgdGV4dCBmb3IgdGhlIHNjcmVlbiByZWFkZXIgdG8gcmVhZCBvdXQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIG91dHB1dE5vZGVUb1RleHRfKG5vZGUpIHtcbiAgICBjb25zdCBibG9ja1RleHQgPSB0aGlzLmdldEJsb2NrVGV4dF8obm9kZS5nZXRTb3VyY2VCbG9jaygpKTtcbiAgICByZXR1cm4gYFlvdSBhcmUgb24gYSBjb25uZWN0aW9uIGZvciBibG9jaywgJHtibG9ja1RleHR9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRleHQgZm9yIGEgbmV4dCBjb25uZWN0aW9uLlxuICAgKiBAcGFyYW0geyFCbG9ja2x5LkFTVE5vZGV9IG5vZGUgVGhlIG5vZGUgdG8gY3JlYXRlIHRleHQgZm9yLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTWFya2VyIFRydWUgdG8gZ2V0IHRoZSB0ZXh0IGZvciBhIG1hcmtlcixcbiAgICogICAgIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgdGV4dCBmb3IgdGhlIHNjcmVlbiByZWFkZXIgdG8gcmVhZCBvdXQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIG5leHROb2RlVG9UZXh0Xyhub2RlLCBpc01hcmtlcikge1xuICAgIGNvbnN0IGJsb2NrID0gbm9kZS5nZXRTb3VyY2VCbG9jaygpO1xuICAgIGNvbnN0IGJsb2NrVGV4dCA9IHRoaXMuZ2V0QmxvY2tUZXh0Xyhub2RlLmdldFNvdXJjZUJsb2NrKCkpO1xuICAgIGxldCBmaW5hbFRleHQgPSAnJztcbiAgICBpZiAoYmxvY2suZ2V0U3Vycm91bmRQYXJlbnQoKSkge1xuICAgICAgY29uc3QgcGFyZW50QmxvY2tUZXh0ID0gdGhpcy5nZXRCbG9ja1RleHRfKGJsb2NrLmdldFN1cnJvdW5kUGFyZW50KCkpO1xuICAgICAgZmluYWxUZXh0ICs9IGBZb3UgYXJlIGluc2lkZSBvZiBibG9jayAke3BhcmVudEJsb2NrVGV4dH0uIC4gYDtcbiAgICB9XG4gICAgZmluYWxUZXh0ICs9IGAke0Jsb2NrbHkuTXNnWydORVhUJ119ICR7YmxvY2tUZXh0fWA7XG4gICAgcmV0dXJuIGZpbmFsVGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRleHQgZm9yIGEgcHJldmlvdXMgY29ubmVjdGlvbi5cbiAgICogQHBhcmFtIHshQmxvY2tseS5BU1ROb2RlfSBub2RlIFRoZSBub2RlIHRvIGNyZWF0ZSB0ZXh0IGZvci5cbiAgICogQHBhcmFtIHtib29sZWFufSBpc01hcmtlciBUcnVlIHRvIGdldCB0aGUgdGV4dCBmb3IgYSBtYXJrZXIsXG4gICAqICAgICBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHRleHQgZm9yIHRoZSBzY3JlZW4gcmVhZGVyIHRvIHJlYWQgb3V0LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBwcmV2aW91c05vZGVUb1RleHRfKG5vZGUsIGlzTWFya2VyKSB7XG4gICAgY29uc3QgYmxvY2sgPSBub2RlLmdldFNvdXJjZUJsb2NrKCk7XG4gICAgY29uc3QgYmxvY2tUZXh0ID0gdGhpcy5nZXRCbG9ja1RleHRfKGJsb2NrKTtcbiAgICBsZXQgZmluYWxUZXh0ID0gJyc7XG4gICAgaWYgKGJsb2NrLmdldFN1cnJvdW5kUGFyZW50KCkpIHtcbiAgICAgIGNvbnN0IHBhcmVudEJsb2NrVGV4dCA9IHRoaXMuZ2V0QmxvY2tUZXh0XyhibG9jay5nZXRTdXJyb3VuZFBhcmVudCgpKTtcbiAgICAgIGZpbmFsVGV4dCArPSBgWW91IGFyZSBpbnNpZGUgb2YgYmxvY2sgJHtwYXJlbnRCbG9ja1RleHR9LiAuIGA7XG4gICAgfVxuXG4gICAgZmluYWxUZXh0ICs9IGAke0Jsb2NrbHkuTXNnWydQUkVWSU9VUyddfSAke2Jsb2NrVGV4dH1gO1xuICAgIHJldHVybiBmaW5hbFRleHQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyB0ZXh0IGZvciBhIHN0YWNrIG9mIGJsb2Nrcy5cbiAgICogQHBhcmFtIHshQmxvY2tseS5BU1ROb2RlfSBub2RlIFRoZSBub2RlIHRvIGNyZWF0ZSB0ZXh0IGZvci5cbiAgICogQHBhcmFtIHshQmxvY2tseS5BU1ROb2RlfSBvbGROb2RlIFRoZSBwcmV2aW91cyBub2RlLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB0ZXh0IGZvciB0aGUgc2NyZWVuIHJlYWRlciB0byByZWFkIG91dC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgc3RhY2tOb2RlVG9UZXh0Xyhub2RlLCBvbGROb2RlKSB7XG4gICAgY29uc3Qgc3JjQmxvY2sgPSBub2RlLmdldFNvdXJjZUJsb2NrKCk7XG4gICAgY29uc3QgbmV3Tm9kZVRvcEJsb2NrID0gc3JjQmxvY2suZ2V0VG9wU3RhY2tCbG9jaygpO1xuICAgIGxldCBvbGROb2RlVG9wQmxvY2sgPSBudWxsO1xuICAgIGlmIChvbGROb2RlICYmIG9sZE5vZGUuZ2V0U291cmNlQmxvY2soKSkge1xuICAgICAgb2xkTm9kZVRvcEJsb2NrID0gb2xkTm9kZS5nZXRTb3VyY2VCbG9jaygpLmdldFRvcFN0YWNrQmxvY2soKTtcbiAgICB9XG5cbiAgICBsZXQgZmluYWxUZXh0ID0gJyc7XG5cbiAgICBpZiAoc3JjQmxvY2sgJiYgc3JjQmxvY2sud29ya3NwYWNlLmlzRmx5b3V0KSB7XG4gICAgICBmaW5hbFRleHQgPSB0aGlzLmdldEJsb2NrVGV4dF8obm9kZS5nZXRTb3VyY2VCbG9jaygpKTtcbiAgICAgIGZpbmFsVGV4dCArPSBgIC4gLiBUbyBhZGQgdGhpcyBibG9jayB0byB0aGUgd29ya3NwYWNlIHByZXNzIEVudGVyLiAuXG4gICAgICBUbyBnbyB0byB0aGUgbmV4dCBibG9jayBoaXQgbmV4dC4gLiBUbyBnbyBiYWNrIHRvIHRoZSB3b3Jrc3BhY2VcbiAgICAgIGhpdCBlc2NhcGUuIGA7XG4gICAgfSBlbHNlIGlmIChzcmNCbG9jaykge1xuICAgICAgaWYgKG9sZE5vZGVUb3BCbG9jayAhPT0gbmV3Tm9kZVRvcEJsb2NrKSB7XG4gICAgICAgIGZpbmFsVGV4dCArPSBgWW91IGFyZSBvbiBhIG5ldyBncm91cCBvZiBibG9ja3MuIGA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaW5hbFRleHQgKz0gYFlvdSBhcmUgb24gYSBncm91cCBvZiBibG9ja3MuIGA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaW5hbFRleHQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyB0ZXh0IGZvciBhIHdvcmtzcGFjZS5cbiAgICogQHBhcmFtIHshQmxvY2tseS5BU1ROb2RlfSBub2RlIFRoZSBub2RlIHRvIGNyZWF0ZSB0ZXh0IGZvci5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgdGV4dCBmb3IgdGhlIHNjcmVlbiByZWFkZXIgdG8gcmVhZCBvdXQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHdvcmtzcGFjZU5vZGVUb1RleHRfKG5vZGUpIHtcbiAgICBjb25zdCB3b3Jrc3BhY2UgPSAvKiogQHR5cGV7QmxvY2tseS5Xb3Jrc3BhY2VTdmd9ICovIChub2RlLmdldExvY2F0aW9uKCkpO1xuICAgIC8vIFRPRE86IEFsbCB0ZXh0IHNob3VsZCBiZSBhZGRlZCB0byBCbG9ja2x5Lk1zZyB0byBhbGxvdyBmb3IgdHJhbnNsYXRpb24uXG4gICAgbGV0IHRleHQgPSBudWxsO1xuICAgIGlmICh3b3Jrc3BhY2UuaXNGbHlvdXQpIHtcbiAgICAgIHRleHQgPSAnSW4gdGhlIGZseW91dCwgcGxlYXNlIHNlbGVjdCBhIGJsb2NrJztcbiAgICB9IGVsc2UgaWYgKHdvcmtzcGFjZS5pc011dGF0b3IpIHtcbiAgICAgIHRleHQgPSAnSW4gdGhlIG11dGF0b3Igd29ya3NwYWNlLCB1c2UgdGhpcyB3b3Jrc3BhY2UgdG8gY2hhbmdlIGEgYmxvY2snO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ZXh0ID0gQmxvY2tseS5Nc2dbJ01BSU5fV1MnXTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNwZWFrZXIgPSBuZXcgU3BlYWtlcigpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/speaker.js\n");

/***/ })

})
webpackHotUpdate("main",{

/***/ "./src/speaker.js":
/*!************************!*\
  !*** ./src/speaker.js ***!
  \************************/
/*! exports provided: Speaker, speaker */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Speaker\", function() { return Speaker; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"speaker\", function() { return speaker; });\n/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blockly/core */ \"./node_modules/blockly/dist/core-browser.js\");\n/* harmony import */ var blockly_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blockly_core__WEBPACK_IMPORTED_MODULE_0__);\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Speaker used for speaking out text.\n */\n\n/**\n * Convenience methods for speaking out text.\n * More information on speakers can be found here:\n * https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesis.\n */\n\nvar Speaker = /*#__PURE__*/function () {\n  /**\n   * Constructor for a speaker.\n   * @param {SpeakerMessages=} optMessages Optional messages for the speaker.\n   */\n  function Speaker(optMessages) {\n    _classCallCheck(this, Speaker);\n\n    var messages = {\n      'MAIN_WS': 'On the main workspace',\n      'STACK': 'To go to the last block in the previous group of blocks, press' + 'previous. To go to the first block in the stack hit next.',\n      'PREVIOUS': 'You are on a connection before, ',\n      'NEXT': 'On a connection after, ',\n      'OUTPUT': 'On an output connection. ',\n      'CONNECTION': 'At a connection point.',\n      'BLOCK': 'On a block of type',\n      'CLICKABLE_FIELD': 'To interact with the field hit enter.',\n      'EMPTY_TOKEN': 'blank',\n      'MARK_CONNECTION': 'To mark the block press enter. ',\n      'EXIT_EDIT_MODE': 'To exit edit mode hit escape. '\n    };\n    blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.utils.object.mixin(messages, optMessages);\n    this.setLocale(messages);\n    this.noOverrides = false;\n  }\n  /**\n   * The messages to be read out by a screen reader.\n   * @typedef {{\n   *     MAIN_WS: string,\n   *     STACK: string,\n   *     PREVIOUS: string,\n   *     NEXT: string,\n   *     OUTPUT: string,\n   *     CONNECTION: string,\n   *     BLOCK: string,\n   *     EMPTY_TOKEN: string,\n   *     MARK_CONNECTION: string,\n   * }} SpeakerMessages\n   */\n\n  /**\n   * Set the messages for the speaker.\n   * @param {!SpeakerMessages} messages The messages needed to create a speaker.\n   */\n\n\n  _createClass(Speaker, [{\n    key: \"setLocale\",\n    value: function setLocale(messages) {\n      Object.keys(messages).forEach(function (k) {\n        blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.Msg[k] = messages[k];\n      });\n    }\n    /**\n     * Speaks out the text that was given to it.\n     * @param {string} text The text to speak out.\n     * @param {boolean=} shouldCancel True to stop the current utterance, false to\n     *     wait until the current utterance is done before speaking.\n     * @param {function=} onEnd The function to run after the text has been\n     *     spoken.\n     * @param {function=} onStart The function run when the text has begun to\n     *     be spoken.\n     * @public\n     */\n\n  }, {\n    key: \"speak\",\n    value: function speak(text, shouldCancel, onEnd, onStart) {\n      var audio = new SpeechSynthesisUtterance(text);\n\n      if (shouldCancel && !this.noOverrides && window.speechSynthesis.speaking) {\n        window.speechSynthesis.cancel();\n      }\n\n      if (onEnd) {\n        audio.onend = onEnd;\n      }\n\n      if (onStart) {\n        audio.onstart = onStart;\n      }\n\n      window.speechSynthesis.speak(audio);\n    }\n    /**\n     * Clears out the queue of text to speak.\n     * @public\n     */\n\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      window.speechSynthesis.cancel();\n    }\n    /**\n     * Pauses speaking.\n     */\n\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      window.speechSynthesis.pause();\n    }\n    /**\n     * Resumes speaking.\n     */\n\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      window.speechSynthesis.resume();\n    }\n    /**\n     * Speaks out text if the event is of type marker or cursor move.\n     * @param {!Blockly.Events} event The event to speak out.\n     */\n\n  }, {\n    key: \"nodeToSpeech\",\n    value: function nodeToSpeech(event) {\n      // TODO: Update this if we link to the current version of blockly.\n      if (event.type === blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.Events.MARKER_MOVE) {\n        var nodeText = this.nodeToText_(event.newNode, event.oldNode, !event.isCursor);\n\n        if (!event.isCursor) {\n          nodeText = \"You have marked a location. To find a new block to connect\\n        to this location hit T. ! . To insert a block on the workspace,\\n        find the location of the block and hit I. \";\n        }\n\n        this.speak(nodeText, true);\n      }\n    }\n    /**\n     * Speaks out the text for a modal.\n     * @param {Element} modal The modal to collect the text to read out.\n     * @public\n     */\n\n  }, {\n    key: \"modalToText\",\n    value: function modalToText(modal) {\n      var header = modal.querySelector('header');\n      var headerText = header.textContent.trim();\n\n      if (headerText !== '') {\n        this.speak(headerText);\n      }\n\n      this.addButtonListeners_(header.querySelectorAll('button'));\n      var mainText = modal.querySelector('main').textContent.trim();\n\n      if (mainText !== '') {\n        this.speak(mainText);\n      }\n\n      var footerBtns = modal.querySelector('footer').querySelectorAll('button');\n      this.addButtonListeners_(footerBtns);\n    }\n    /**\n     * Adds listeners for when the button is focused.\n     * @param {!NodeList} btns The buttons to add listeners to.\n     * @private\n     */\n\n  }, {\n    key: \"addButtonListeners_\",\n    value: function addButtonListeners_(btns) {\n      var _this = this;\n\n      var _iterator = _createForOfIteratorHelper(btns),\n          _step;\n\n      try {\n        var _loop = function _loop() {\n          var btn = _step.value;\n          btn.addEventListener('focus', function () {\n            _this.buttonToSpeech_(btns, btn, true);\n          });\n\n          if (document.activeElement === btn) {\n            _this.buttonToSpeech_(btns, btn, false);\n          }\n        };\n\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    /**\n     * Speaks out information about a button.\n     * @param {NodeList} btns The list of buttons on the modal.\n     * @param {Element} btn The button.\n     * @param {boolean} shouldCancel True if this should cancel the previous\n     *     utterance.\n     * @private\n     */\n\n  }, {\n    key: \"buttonToSpeech_\",\n    value: function buttonToSpeech_(btns, btn, shouldCancel) {\n      this.speak('Hit enter to ', shouldCancel);\n\n      if (btn.textContent === '') {\n        this.speak(btn.getAttribute('aria-label'));\n      } else {\n        this.speak(btn.textContent);\n      }\n\n      if (btns.length > 0) {\n        this.speak('Hit tab to go to your next option');\n      }\n    }\n    /**\n     * Speaks out an audio representation of the given node.\n     * @param {Blockly.ASTNode} node The node to speak out.\n     * @param {Blockly.ASTNode} oldNode The previous node to speak out.\n     * @param {boolean} isMarker True to get the text for a marker,\n     *     false otherwise.\n     * @return {string} The text representation of the node.\n     * @public\n     */\n\n  }, {\n    key: \"nodeToText_\",\n    value: function nodeToText_(node, oldNode, isMarker) {\n      var finalText = '';\n\n      switch (node.getType()) {\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.FIELD:\n          finalText = this.fieldNodeToText_(node);\n          break;\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.BLOCK:\n          finalText = this.blockNodeToText_(node);\n          break;\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.INPUT:\n          finalText = this.inputNodeToText_(node, isMarker);\n          break;\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.OUTPUT:\n          finalText = this.outputNodeToText_(node, isMarker);\n          break;\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.NEXT:\n          finalText = this.nextNodeToText_(node, isMarker);\n          break;\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.PREVIOUS:\n          finalText = this.previousNodeToText_(node, isMarker);\n          break;\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.STACK:\n          finalText = this.stackNodeToText_(node, oldNode);\n          break;\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.WORKSPACE:\n          finalText = this.workspaceNodeToText_(node);\n          break;\n\n        default:\n          return node.toString();\n      }\n\n      finalText += this.getNextOptions_(node, oldNode, isMarker);\n      return finalText;\n    }\n    /**\n     * Gets text explaining the next options available for a user.\n     * @param {!Blockly.ASTNode} node The current node.\n     * @param {!Blockly.ASTNode} oldNode The previous node.\n     * @param {boolean} isMarker True if the marker was moved.\n     * @return {string} Text explaining next options for the field.\n     * @private\n     */\n\n  }, {\n    key: \"getNextOptions_\",\n    value: function getNextOptions_(node, oldNode, isMarker) {\n      switch (node.getType()) {\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.FIELD:\n          return this.getFieldOptions_(node);\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.BLOCK:\n          return this.getBlockOptions_(node);\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.INPUT:\n          return this.getConnectionOptions_(node, isMarker);\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.OUTPUT:\n          return this.getConnectionOptions_(node, isMarker);\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.NEXT:\n          return this.getConnectionOptions_(node, isMarker);\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.PREVIOUS:\n          return this.getConnectionOptions_(node, isMarker);\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.STACK:\n          return this.getStackOptions_(node);\n\n        case blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.ASTNode.types.WORKSPACE:\n          return '';\n\n        default:\n          return node.toString();\n      }\n    }\n    /**\n     * Gets the next options for when a user is on a field.\n     * This is to open the field or to change locations.\n     * @param {!Blockly.ASTNode} node The field node.\n     * @return {string} The text explaining the next options when a user is on a\n     *     field.\n     * @private\n     */\n\n  }, {\n    key: \"getFieldOptions_\",\n    value: function getFieldOptions_(node) {\n      var field = node.getLocation();\n\n      if (field.isClickable()) {\n        return \"To interact with the field hit enter. Use the next or previous\\n      keys to change locations. \";\n      } else {\n        return 'Use the next or previous keys to change locations. ';\n      }\n    }\n    /**\n     * Gets the next options for when a user is on a block.\n     * @return {string} The text explaining the next options for a block.\n     * @private\n     */\n\n  }, {\n    key: \"getBlockOptions_\",\n    value: function getBlockOptions_() {\n      return \"Use the next or previous keys to change locations. \";\n    }\n    /**\n     * Gets the text for the connection point.\n     * @param {!Blockly.ASTNode} node The connection node.\n     * @param {boolean} isMarker True if the marker was moved.\n     * @return {string} The text explaining the next options when a user is on a\n     *     connection.\n     * @private\n     */\n\n  }, {\n    key: \"getConnectionOptions_\",\n    value: function getConnectionOptions_(node, isMarker) {\n      var markerText = \". To mark this location, hit enter. To change locations use the next or previous keys\";\n      var finalText = '';\n\n      if (!isMarker) {\n        finalText += \"\".concat(markerText);\n      }\n\n      return finalText;\n    }\n    /**\n     * Gets the options for a user on a  stack of blocks.\n     * @return {string} The text explaining the next options when a user is on a\n     *     stack of blocks.\n     * @private\n     */\n\n  }, {\n    key: \"getStackOptions_\",\n    value: function getStackOptions_(node) {\n      var finalText = '';\n\n      if (node.prev()) {\n        finalText += \"To go to the last block in the previous group of blocks,\\n      press previous.\";\n      }\n\n      finalText += \" To go to the first block in the stack hit next.\";\n      return finalText;\n    }\n    /**\n     * Get the text for the source block of the node.\n     * @param {!Blockly.BlockSvg} srcBlock The block to get the text for.\n     * @param {string=} opt_emptyToken The optional empty token.\n     * @return {string} The text describing the source block of the node.\n     * @private\n     */\n\n  }, {\n    key: \"getBlockText_\",\n    value: function getBlockText_(srcBlock, opt_emptyToken) {\n      var emptyToken = opt_emptyToken || blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.Msg['EMPTY_TOKEN'];\n\n      if (srcBlock) {\n        if (srcBlock.statementInputCount > 0) {\n          emptyToken = ' do blank ';\n        }\n\n        return srcBlock.toString(null, emptyToken);\n      } else {\n        return '';\n      }\n    }\n    /**\n     * Creates text for a feild.\n     * @param {!Blockly.ASTNode} node The node to create text for.\n     * @return {string} The text for the screen reader to read out.\n     * @protected\n     */\n\n  }, {\n    key: \"fieldNodeToText_\",\n    value: function fieldNodeToText_(node) {\n      var field = node.getLocation();\n      return field.getText() + '. ';\n    }\n    /**\n     * Creates text for a feild.\n     * @param {!Blockly.ASTNode} node The node to create text for.\n     * @return {string} The text for the screen reader to read out.\n     * @protected\n     */\n\n  }, {\n    key: \"blockNodeToText_\",\n    value: function blockNodeToText_(node) {\n      var block =\n      /** @type{Blockly.BlockSvg} */\n      node.getLocation();\n      var blockText = this.getBlockText_(block);\n      var finalText = '';\n\n      if (block.getSurroundParent()) {\n        var parentBlockText = this.getBlockText_(block.getSurroundParent());\n        finalText += \"You are inside of block \".concat(parentBlockText, \". . \");\n      }\n\n      finalText += \"You are on , \".concat(blockText, \". . \");\n      return finalText;\n    }\n    /**\n     * Creates text for an input.\n     * @param {!Blockly.ASTNode} node The node to create text for.\n     * @param {boolean} isMarker True if the marker was moved.\n     * @return {string} The text for the screen reader to read out.\n     * @protected\n     */\n\n  }, {\n    key: \"inputNodeToText_\",\n    value: function inputNodeToText_(node, isMarker) {\n      var inputConnection =\n      /** @type{Blockly.Input} */\n      node.getLocation();\n      var connectionText = \"You are on a connection\";\n      var finalText = '';\n\n      if (inputConnection.type === blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.NEXT_STATEMENT) {\n        var blockText = this.getBlockText_(node.getSourceBlock());\n        finalText = \"Inside \".concat(blockText, \". \").concat(connectionText, \". \");\n      } else if (inputConnection.type === blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.INPUT_VALUE) {\n        var _blockText = this.getBlockText_(node.getSourceBlock(), ' ');\n\n        finalText = \"\".concat(connectionText, \" after \").concat(_blockText);\n      }\n\n      return finalText;\n    }\n    /**\n     * Creates text for a output connection.\n     * @param {!Blockly.ASTNode} node The node to create text for.\n     * @return {string} The text for the screen reader to read out.\n     * @protected\n     */\n\n  }, {\n    key: \"outputNodeToText_\",\n    value: function outputNodeToText_(node) {\n      var blockText = this.getBlockText_(node.getSourceBlock());\n      return \"You are on a connection for block, \".concat(blockText);\n    }\n    /**\n     * Creates text for a next connection.\n     * @param {!Blockly.ASTNode} node The node to create text for.\n     * @param {boolean} isMarker True to get the text for a marker,\n     *     false otherwise.\n     * @return {string} The text for the screen reader to read out.\n     * @protected\n     */\n\n  }, {\n    key: \"nextNodeToText_\",\n    value: function nextNodeToText_(node, isMarker) {\n      var block = node.getSourceBlock();\n      var blockText = this.getBlockText_(node.getSourceBlock());\n      var finalText = '';\n\n      if (block.getSurroundParent()) {\n        var parentBlockText = this.getBlockText_(block.getSurroundParent());\n        finalText += \"You are inside of block \".concat(parentBlockText, \". . \");\n      }\n\n      finalText += \"\".concat(blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.Msg['NEXT'], \" \").concat(blockText);\n      return finalText;\n    }\n    /**\n     * Creates text for a previous connection.\n     * @param {!Blockly.ASTNode} node The node to create text for.\n     * @param {boolean} isMarker True to get the text for a marker,\n     *     false otherwise.\n     * @return {string} The text for the screen reader to read out.\n     * @protected\n     */\n\n  }, {\n    key: \"previousNodeToText_\",\n    value: function previousNodeToText_(node, isMarker) {\n      var block = node.getSourceBlock();\n      var blockText = this.getBlockText_(block);\n      var finalText = '';\n\n      if (block.getSurroundParent()) {\n        var parentBlockText = this.getBlockText_(block.getSurroundParent());\n        finalText += \"You are inside of block \".concat(parentBlockText, \". . \");\n      }\n\n      finalText += \"\".concat(blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.Msg['PREVIOUS'], \" \").concat(blockText);\n      return finalText;\n    }\n    /**\n     * Creates text for a stack of blocks.\n     * @param {!Blockly.ASTNode} node The node to create text for.\n     * @param {!Blockly.ASTNode} oldNode The previous node.\n     * @return {string} The text for the screen reader to read out.\n     * @protected\n     */\n\n  }, {\n    key: \"stackNodeToText_\",\n    value: function stackNodeToText_(node, oldNode) {\n      var srcBlock = node.getSourceBlock();\n      var newNodeTopBlock = srcBlock.getTopStackBlock();\n      var oldNodeTopBlock = null;\n\n      if (oldNode && oldNode.getSourceBlock()) {\n        oldNodeTopBlock = oldNode.getSourceBlock().getTopStackBlock();\n      }\n\n      var finalText = '';\n\n      if (srcBlock && srcBlock.workspace.isFlyout) {\n        finalText = this.getBlockText_(node.getSourceBlock());\n        finalText += \" . . To add this block to the workspace press Enter. .\\n      To go to the next block hit next. . To go back to the workspace\\n      hit escape. \";\n      } else if (srcBlock) {\n        if (oldNodeTopBlock !== newNodeTopBlock) {\n          finalText += \"You are on a new group of blocks. \";\n        } else {\n          finalText += \"You are on a group of blocks. \";\n        }\n      }\n\n      return finalText;\n    }\n    /**\n     * Creates text for a workspace.\n     * @param {!Blockly.ASTNode} node The node to create text for.\n     * @return {string} The text for the screen reader to read out.\n     * @protected\n     */\n\n  }, {\n    key: \"workspaceNodeToText_\",\n    value: function workspaceNodeToText_(node) {\n      var workspace =\n      /** @type{Blockly.WorkspaceSvg} */\n      node.getLocation(); // TODO: All text should be added to Blockly.Msg to allow for translation.\n\n      var text = null;\n\n      if (workspace.isFlyout) {\n        text = 'In the flyout, please select a block';\n      } else if (workspace.isMutator) {\n        text = 'In the mutator workspace, use this workspace to change a block';\n      } else {\n        text = blockly_core__WEBPACK_IMPORTED_MODULE_0___default.a.Msg['MAIN_WS'];\n      }\n\n      return text;\n    }\n  }]);\n\n  return Speaker;\n}();\nvar speaker = new Speaker();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3BlYWtlci5qcz9jZDc3Il0sIm5hbWVzIjpbIlNwZWFrZXIiLCJvcHRNZXNzYWdlcyIsIm1lc3NhZ2VzIiwiQmxvY2tseSIsInV0aWxzIiwib2JqZWN0IiwibWl4aW4iLCJzZXRMb2NhbGUiLCJub092ZXJyaWRlcyIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwiayIsIk1zZyIsInRleHQiLCJzaG91bGRDYW5jZWwiLCJvbkVuZCIsIm9uU3RhcnQiLCJhdWRpbyIsIlNwZWVjaFN5bnRoZXNpc1V0dGVyYW5jZSIsIndpbmRvdyIsInNwZWVjaFN5bnRoZXNpcyIsInNwZWFraW5nIiwiY2FuY2VsIiwib25lbmQiLCJvbnN0YXJ0Iiwic3BlYWsiLCJwYXVzZSIsInJlc3VtZSIsImV2ZW50IiwidHlwZSIsIkV2ZW50cyIsIk1BUktFUl9NT1ZFIiwibm9kZVRleHQiLCJub2RlVG9UZXh0XyIsIm5ld05vZGUiLCJvbGROb2RlIiwiaXNDdXJzb3IiLCJtb2RhbCIsImhlYWRlciIsInF1ZXJ5U2VsZWN0b3IiLCJoZWFkZXJUZXh0IiwidGV4dENvbnRlbnQiLCJ0cmltIiwiYWRkQnV0dG9uTGlzdGVuZXJzXyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJtYWluVGV4dCIsImZvb3RlckJ0bnMiLCJidG5zIiwiYnRuIiwiYWRkRXZlbnRMaXN0ZW5lciIsImJ1dHRvblRvU3BlZWNoXyIsImRvY3VtZW50IiwiYWN0aXZlRWxlbWVudCIsImdldEF0dHJpYnV0ZSIsImxlbmd0aCIsIm5vZGUiLCJpc01hcmtlciIsImZpbmFsVGV4dCIsImdldFR5cGUiLCJBU1ROb2RlIiwidHlwZXMiLCJGSUVMRCIsImZpZWxkTm9kZVRvVGV4dF8iLCJCTE9DSyIsImJsb2NrTm9kZVRvVGV4dF8iLCJJTlBVVCIsImlucHV0Tm9kZVRvVGV4dF8iLCJPVVRQVVQiLCJvdXRwdXROb2RlVG9UZXh0XyIsIk5FWFQiLCJuZXh0Tm9kZVRvVGV4dF8iLCJQUkVWSU9VUyIsInByZXZpb3VzTm9kZVRvVGV4dF8iLCJTVEFDSyIsInN0YWNrTm9kZVRvVGV4dF8iLCJXT1JLU1BBQ0UiLCJ3b3Jrc3BhY2VOb2RlVG9UZXh0XyIsInRvU3RyaW5nIiwiZ2V0TmV4dE9wdGlvbnNfIiwiZ2V0RmllbGRPcHRpb25zXyIsImdldEJsb2NrT3B0aW9uc18iLCJnZXRDb25uZWN0aW9uT3B0aW9uc18iLCJnZXRTdGFja09wdGlvbnNfIiwiZmllbGQiLCJnZXRMb2NhdGlvbiIsImlzQ2xpY2thYmxlIiwibWFya2VyVGV4dCIsInByZXYiLCJzcmNCbG9jayIsIm9wdF9lbXB0eVRva2VuIiwiZW1wdHlUb2tlbiIsInN0YXRlbWVudElucHV0Q291bnQiLCJnZXRUZXh0IiwiYmxvY2siLCJibG9ja1RleHQiLCJnZXRCbG9ja1RleHRfIiwiZ2V0U3Vycm91bmRQYXJlbnQiLCJwYXJlbnRCbG9ja1RleHQiLCJpbnB1dENvbm5lY3Rpb24iLCJjb25uZWN0aW9uVGV4dCIsIk5FWFRfU1RBVEVNRU5UIiwiZ2V0U291cmNlQmxvY2siLCJJTlBVVF9WQUxVRSIsIm5ld05vZGVUb3BCbG9jayIsImdldFRvcFN0YWNrQmxvY2siLCJvbGROb2RlVG9wQmxvY2siLCJ3b3Jrc3BhY2UiLCJpc0ZseW91dCIsImlzTXV0YXRvciIsInNwZWFrZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ08sSUFBTUEsT0FBYjtBQUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0UsbUJBQVlDLFdBQVosRUFBeUI7QUFBQTs7QUFDdkIsUUFBTUMsUUFBUSxHQUFHO0FBQ2YsaUJBQVcsdUJBREk7QUFFZixlQUNJLG1FQUNBLDJEQUpXO0FBS2Ysa0JBQVksa0NBTEc7QUFNZixjQUFRLHlCQU5PO0FBT2YsZ0JBQVUsMkJBUEs7QUFRZixvQkFBYyx3QkFSQztBQVNmLGVBQVMsb0JBVE07QUFVZix5QkFBbUIs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QVMsR0FBRyxLQUFLc0MsYUFBTCxDQUFtQnhDLElBQUksQ0FBQzhDLGNBQUwsRUFBbkIsQ0FBWjtBQUNBNUMsaUJBQVMsdUpBQVQ7QUFHRCxPQUxELE1BS08sSUFBSStCLFFBQUosRUFBYztBQUNuQixZQUFJaUIsZUFBZSxLQUFLRixlQUF4QixFQUF5QztBQUN2QzlDLG1CQUFTLHdDQUFUO0FBQ0QsU0FGRCxNQUVPO0FBQ0xBLG1CQUFTLG9DQUFUO0FBQ0Q7QUFDRjs7QUFDRCxhQUFPQSxTQUFQO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBdmRBO0FBQUE7QUFBQSx5Q0F3ZHVCRixJQXhkdkIsRUF3ZDZCO0FBQ3pCLFVBQU1tRCxTQUFTO0FBQUc7QUFBb0NuRCxVQUFJLENBQUM2QixXQUFMLEVBQXRELENBRHlCLENBRXpCOztBQUNBLFVBQUl2RSxJQUFJLEdBQUcsSUFBWDs7QUFDQSxVQUFJNkYsU0FBUyxDQUFDQyxRQUFkLEVBQXdCO0FBQ3RCOUYsWUFBSSxHQUFHLHNDQUFQO0FBQ0QsT0FGRCxNQUVPLElBQUk2RixTQUFTLENBQUNFLFNBQWQsRUFBeUI7QUFDOUIvRixZQUFJLEdBQUcsZ0VBQVA7QUFDRCxPQUZNLE1BRUE7QUFDTEEsWUFBSSxHQUFHWCxtREFBTyxDQUFDVSxHQUFSLENBQVksU0FBWixDQUFQO0FBQ0Q7O0FBQ0QsYUFBT0MsSUFBUDtBQUNEO0FBcGVIOztBQUFBO0FBQUE7QUF1ZU8sSUFBTWdHLE9BQU8sR0FBRyxJQUFJOUcsT0FBSixFQUFoQiIsImZpbGUiOiIuL3NyYy9zcGVha2VyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBTcGVha2VyIHVzZWQgZm9yIHNwZWFraW5nIG91dCB0ZXh0LlxuICovXG5cbmltcG9ydCBCbG9ja2x5IGZyb20gJ2Jsb2NrbHkvY29yZSc7XG5cbi8qKlxuICogQ29udmVuaWVuY2UgbWV0aG9kcyBmb3Igc3BlYWtpbmcgb3V0IHRleHQuXG4gKiBNb3JlIGluZm9ybWF0aW9uIG9uIHNwZWFrZXJzIGNhbiBiZSBmb3VuZCBoZXJlOlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NwZWVjaFN5bnRoZXNpcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFNwZWFrZXIge1xuICAvKipcbiAgICogQ29uc3RydWN0b3IgZm9yIGEgc3BlYWtlci5cbiAgICogQHBhcmFtIHtTcGVha2VyTWVzc2FnZXM9fSBvcHRNZXNzYWdlcyBPcHRpb25hbCBtZXNzYWdlcyBmb3IgdGhlIHNwZWFrZXIuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRNZXNzYWdlcykge1xuICAgIGNvbnN0IG1lc3NhZ2VzID0ge1xuICAgICAgJ01BSU5fV1MnOiAnT24gdGhlIG1haW4gd29ya3NwYWNlJyxcbiAgICAgICdTVEFDSyc6XG4gICAgICAgICAgJ1RvIGdvIHRvIHRoZSBsYXN0IGJsb2NrIGluIHRoZSBwcmV2aW91cyBncm91cCBvZiBibG9ja3MsIHByZXNzJyArXG4gICAgICAgICAgJ3ByZXZpb3VzLiBUbyBnbyB0byB0aGUgZmlyc3QgYmxvY2sgaW4gdGhlIHN0YWNrIGhpdCBuZXh0LicsXG4gICAgICAnUFJFVklPVVMnOiAnWW91IGFyZSBvbiBhIGNvbm5lY3Rpb24gYmVmb3JlLCAnLFxuICAgICAgJ05FWFQnOiAnT24gYSBjb25uZWN0aW9uIGFmdGVyLCAnLFxuICAgICAgJ09VVFBVVCc6ICdPbiBhbiBvdXRwdXQgY29ubmVjdGlvbi4gJyxcbiAgICAgICdDT05ORUNUSU9OJzogJ0F0IGEgY29ubmVjdGlvbiBwb2ludC4nLFxuICAgICAgJ0JMT0NLJzogJ09uIGEgYmxvY2sgb2YgdHlwZScsXG4gICAgICAnQ0xJQ0tBQkxFX0ZJRUxEJzogJ1RvIGludGVyYWN0IHdpdGggdGhlIGZpZWxkIGhpdCBlbnRlci4nLFxuICAgICAgJ0VNUFRZX1RPS0VOJzogJ2JsYW5rJyxcbiAgICAgICdNQVJLX0NPTk5FQ1RJT04nOiAnVG8gbWFyayB0aGUgYmxvY2sgcHJlc3MgZW50ZXIuICcsXG4gICAgICAnRVhJVF9FRElUX01PREUnOiAnVG8gZXhpdCBlZGl0IG1vZGUgaGl0IGVzY2FwZS4gJyxcbiAgICB9O1xuXG4gICAgQmxvY2tseS51dGlscy5vYmplY3QubWl4aW4obWVzc2FnZXMsIG9wdE1lc3NhZ2VzKTtcblxuICAgIHRoaXMuc2V0TG9jYWxlKG1lc3NhZ2VzKTtcbiAgICB0aGlzLm5vT3ZlcnJpZGVzID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogVGhlIG1lc3NhZ2VzIHRvIGJlIHJlYWQgb3V0IGJ5IGEgc2NyZWVuIHJlYWRlci5cbiAgICogQHR5cGVkZWYge3tcbiAgICogICAgIE1BSU5fV1M6IHN0cmluZyxcbiAgICogICAgIFNUQUNLOiBzdHJpbmcsXG4gICAqICAgICBQUkVWSU9VUzogc3RyaW5nLFxuICAgKiAgICAgTkVYVDogc3RyaW5nLFxuICAgKiAgICAgT1VUUFVUOiBzdHJpbmcsXG4gICAqICAgICBDT05ORUNUSU9OOiBzdHJpbmcsXG4gICAqICAgICBCTE9DSzogc3RyaW5nLFxuICAgKiAgICAgRU1QVFlfVE9LRU46IHN0cmluZyxcbiAgICogICAgIE1BUktfQ09OTkVDVElPTjogc3RyaW5nLFxuICAgKiB9fSBTcGVha2VyTWVzc2FnZXNcbiAgICovXG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbWVzc2FnZXMgZm9yIHRoZSBzcGVha2VyLlxuICAgKiBAcGFyYW0geyFTcGVha2VyTWVzc2FnZXN9IG1lc3NhZ2VzIFRoZSBtZXNzYWdlcyBuZWVkZWQgdG8gY3JlYXRlIGEgc3BlYWtlci5cbiAgICovXG4gIHNldExvY2FsZShtZXNzYWdlcykge1xuICAgIE9iamVjdC5rZXlzKG1lc3NhZ2VzKS5mb3JFYWNoKChrKSA9PiB7XG4gICAgICBCbG9ja2x5Lk1zZ1trXSA9IG1lc3NhZ2VzW2tdO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwZWFrcyBvdXQgdGhlIHRleHQgdGhhdCB3YXMgZ2l2ZW4gdG8gaXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIHNwZWFrIG91dC5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gc2hvdWxkQ2FuY2VsIFRydWUgdG8gc3RvcCB0aGUgY3VycmVudCB1dHRlcmFuY2UsIGZhbHNlIHRvXG4gICAqICAgICB3YWl0IHVudGlsIHRoZSBjdXJyZW50IHV0dGVyYW5jZSBpcyBkb25lIGJlZm9yZSBzcGVha2luZy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbj19IG9uRW5kIFRoZSBmdW5jdGlvbiB0byBydW4gYWZ0ZXIgdGhlIHRleHQgaGFzIGJlZW5cbiAgICogICAgIHNwb2tlbi5cbiAgICogQHBhcmFtIHtmdW5jdGlvbj19IG9uU3RhcnQgVGhlIGZ1bmN0aW9uIHJ1biB3aGVuIHRoZSB0ZXh0IGhhcyBiZWd1biB0b1xuICAgKiAgICAgYmUgc3Bva2VuLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBzcGVhayh0ZXh0LCBzaG91bGRDYW5jZWwsIG9uRW5kLCBvblN0YXJ0KSB7XG4gICAgY29uc3QgYXVkaW8gPSBuZXcgU3BlZWNoU3ludGhlc2lzVXR0ZXJhbmNlKHRleHQpO1xuXG4gICAgaWYgKHNob3VsZENhbmNlbCAmJiAhdGhpcy5ub092ZXJyaWRlcyAmJiB3aW5kb3cuc3BlZWNoU3ludGhlc2lzLnNwZWFraW5nKSB7XG4gICAgICB3aW5kb3cuc3BlZWNoU3ludGhlc2lzLmNhbmNlbCgpO1xuICAgIH1cblxuICAgIGlmIChvbkVuZCkge1xuICAgICAgYXVkaW8ub25lbmQgPSBvbkVuZDtcbiAgICB9XG5cbiAgICBpZiAob25TdGFydCkge1xuICAgICAgYXVkaW8ub25zdGFydCA9IG9uU3RhcnQ7XG4gICAgfVxuICAgIHdpbmRvdy5zcGVlY2hTeW50aGVzaXMuc3BlYWsoYXVkaW8pO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyBvdXQgdGhlIHF1ZXVlIG9mIHRleHQgdG8gc3BlYWsuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNhbmNlbCgpIHtcbiAgICB3aW5kb3cuc3BlZWNoU3ludGhlc2lzLmNhbmNlbCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdXNlcyBzcGVha2luZy5cbiAgICovXG4gIHBhdXNlKCkge1xuICAgIHdpbmRvdy5zcGVlY2hTeW50aGVzaXMucGF1c2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN1bWVzIHNwZWFraW5nLlxuICAgKi9cbiAgcmVzdW1lKCkge1xuICAgIHdpbmRvdy5zcGVlY2hTeW50aGVzaXMucmVzdW1lKCk7XG4gIH1cblxuICAvKipcbiAgICogU3BlYWtzIG91dCB0ZXh0IGlmIHRoZSBldmVudCBpcyBvZiB0eXBlIG1hcmtlciBvciBjdXJzb3IgbW92ZS5cbiAgICogQHBhcmFtIHshQmxvY2tseS5FdmVudHN9IGV2ZW50IFRoZSBldmVudCB0byBzcGVhayBvdXQuXG4gICAqL1xuICBub2RlVG9TcGVlY2goZXZlbnQpIHtcbiAgICAvLyBUT0RPOiBVcGRhdGUgdGhpcyBpZiB3ZSBsaW5rIHRvIHRoZSBjdXJyZW50IHZlcnNpb24gb2YgYmxvY2tseS5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gQmxvY2tseS5FdmVudHMuTUFSS0VSX01PVkUpIHtcbiAgICAgIGxldCBub2RlVGV4dCA9IHRoaXMubm9kZVRvVGV4dF8oZXZlbnQubmV3Tm9kZSwgZXZlbnQub2xkTm9kZSwgIWV2ZW50LmlzQ3Vyc29yKTtcbiAgICAgIGlmICghZXZlbnQuaXNDdXJzb3IpIHtcbiAgICAgICAgbm9kZVRleHQgPSBgWW91IGhhdmUgbWFya2VkIGEgbG9jYXRpb24uIFRvIGZpbmQgYSBuZXcgYmxvY2sgdG8gY29ubmVjdFxuICAgICAgICB0byB0aGlzIGxvY2F0aW9uIGhpdCBULiAhIC4gVG8gaW5zZXJ0IGEgYmxvY2sgb24gdGhlIHdvcmtzcGFjZSxcbiAgICAgICAgZmluZCB0aGUgbG9jYXRpb24gb2YgdGhlIGJsb2NrIGFuZCBoaXQgSS4gYDtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3BlYWsobm9kZVRleHQsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTcGVha3Mgb3V0IHRoZSB0ZXh0IGZvciBhIG1vZGFsLlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG1vZGFsIFRoZSBtb2RhbCB0byBjb2xsZWN0IHRoZSB0ZXh0IHRvIHJlYWQgb3V0LlxuICAgKiBAcHVibGljXG4gICAqL1xuICBtb2RhbFRvVGV4dChtb2RhbCkge1xuICAgIGNvbnN0IGhlYWRlciA9IG1vZGFsLnF1ZXJ5U2VsZWN0b3IoJ2hlYWRlcicpO1xuICAgIGNvbnN0IGhlYWRlclRleHQgPSBoZWFkZXIudGV4dENvbnRlbnQudHJpbSgpO1xuICAgIGlmIChoZWFkZXJUZXh0ICE9PSAnJykge1xuICAgICAgdGhpcy5zcGVhayhoZWFkZXJUZXh0KTtcbiAgICB9XG4gICAgdGhpcy5hZGRCdXR0b25MaXN0ZW5lcnNfKGhlYWRlci5xdWVyeVNlbGVjdG9yQWxsKCdidXR0b24nKSk7XG5cbiAgICBjb25zdCBtYWluVGV4dCA9IG1vZGFsLnF1ZXJ5U2VsZWN0b3IoJ21haW4nKS50ZXh0Q29udGVudC50cmltKCk7XG5cbiAgICBpZiAobWFpblRleHQgIT09ICcnKSB7XG4gICAgICB0aGlzLnNwZWFrKG1haW5UZXh0KTtcbiAgICB9XG5cbiAgICBjb25zdCBmb290ZXJCdG5zID0gbW9kYWwucXVlcnlTZWxlY3RvcignZm9vdGVyJykucXVlcnlTZWxlY3RvckFsbCgnYnV0dG9uJyk7XG4gICAgdGhpcy5hZGRCdXR0b25MaXN0ZW5lcnNfKGZvb3RlckJ0bnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgbGlzdGVuZXJzIGZvciB3aGVuIHRoZSBidXR0b24gaXMgZm9jdXNlZC5cbiAgICogQHBhcmFtIHshTm9kZUxpc3R9IGJ0bnMgVGhlIGJ1dHRvbnMgdG8gYWRkIGxpc3RlbmVycyB0by5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFkZEJ1dHRvbkxpc3RlbmVyc18oYnRucykge1xuICAgIGZvciAoY29uc3QgYnRuIG9mIGJ0bnMpIHtcbiAgICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsICgpID0+IHtcbiAgICAgICAgdGhpcy5idXR0b25Ub1NwZWVjaF8oYnRucywgYnRuLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGJ0bikge1xuICAgICAgICB0aGlzLmJ1dHRvblRvU3BlZWNoXyhidG5zLCBidG4sIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3BlYWtzIG91dCBpbmZvcm1hdGlvbiBhYm91dCBhIGJ1dHRvbi5cbiAgICogQHBhcmFtIHtOb2RlTGlzdH0gYnRucyBUaGUgbGlzdCBvZiBidXR0b25zIG9uIHRoZSBtb2RhbC5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBidG4gVGhlIGJ1dHRvbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBzaG91bGRDYW5jZWwgVHJ1ZSBpZiB0aGlzIHNob3VsZCBjYW5jZWwgdGhlIHByZXZpb3VzXG4gICAqICAgICB1dHRlcmFuY2UuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBidXR0b25Ub1NwZWVjaF8oYnRucywgYnRuLCBzaG91bGRDYW5jZWwpIHtcbiAgICB0aGlzLnNwZWFrKCdIaXQgZW50ZXIgdG8gJywgc2hvdWxkQ2FuY2VsKTtcbiAgICBpZiAoYnRuLnRleHRDb250ZW50ID09PSAnJykge1xuICAgICAgdGhpcy5zcGVhayhidG4uZ2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNwZWFrKGJ0bi50ZXh0Q29udGVudCk7XG4gICAgfVxuICAgIGlmIChidG5zLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuc3BlYWsoJ0hpdCB0YWIgdG8gZ28gdG8geW91ciBuZXh0IG9wdGlvbicpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTcGVha3Mgb3V0IGFuIGF1ZGlvIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBub2RlLlxuICAgKiBAcGFyYW0ge0Jsb2NrbHkuQVNUTm9kZX0gbm9kZSBUaGUgbm9kZSB0byBzcGVhayBvdXQuXG4gICAqIEBwYXJhbSB7QmxvY2tseS5BU1ROb2RlfSBvbGROb2RlIFRoZSBwcmV2aW91cyBub2RlIHRvIHNwZWFrIG91dC5cbiAgICogQHBhcmFtIHtib29sZWFufSBpc01hcmtlciBUcnVlIHRvIGdldCB0aGUgdGV4dCBmb3IgYSBtYXJrZXIsXG4gICAqICAgICBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHRleHQgcmVwcmVzZW50YXRpb24gb2YgdGhlIG5vZGUuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIG5vZGVUb1RleHRfKG5vZGUsIG9sZE5vZGUsIGlzTWFya2VyKSB7XG4gICAgbGV0IGZpbmFsVGV4dCA9ICcnO1xuICAgIHN3aXRjaCAobm9kZS5nZXRUeXBlKCkpIHtcbiAgICAgIGNhc2UgQmxvY2tseS5BU1ROb2RlLnR5cGVzLkZJRUxEOlxuICAgICAgICBmaW5hbFRleHQgPSB0aGlzLmZpZWxkTm9kZVRvVGV4dF8obm9kZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBCbG9ja2x5LkFTVE5vZGUudHlwZXMuQkxPQ0s6XG4gICAgICAgIGZpbmFsVGV4dCA9IHRoaXMuYmxvY2tOb2RlVG9UZXh0Xyhub2RlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEJsb2NrbHkuQVNUTm9kZS50eXBlcy5JTlBVVDpcbiAgICAgICAgZmluYWxUZXh0ID0gdGhpcy5pbnB1dE5vZGVUb1RleHRfKG5vZGUsIGlzTWFya2VyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEJsb2NrbHkuQVNUTm9kZS50eXBlcy5PVVRQVVQ6XG4gICAgICAgIGZpbmFsVGV4dCA9IHRoaXMub3V0cHV0Tm9kZVRvVGV4dF8obm9kZSwgaXNNYXJrZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQmxvY2tseS5BU1ROb2RlLnR5cGVzLk5FWFQ6XG4gICAgICAgIGZpbmFsVGV4dCA9IHRoaXMubmV4dE5vZGVUb1RleHRfKG5vZGUsIGlzTWFya2VyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEJsb2NrbHkuQVNUTm9kZS50eXBlcy5QUkVWSU9VUzpcbiAgICAgICAgZmluYWxUZXh0ID0gdGhpcy5wcmV2aW91c05vZGVUb1RleHRfKG5vZGUsIGlzTWFya2VyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEJsb2NrbHkuQVNUTm9kZS50eXBlcy5TVEFDSzpcbiAgICAgICAgZmluYWxUZXh0ID0gdGhpcy5zdGFja05vZGVUb1RleHRfKG5vZGUsIG9sZE5vZGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQmxvY2tseS5BU1ROb2RlLnR5cGVzLldPUktTUEFDRTpcbiAgICAgICAgZmluYWxUZXh0ID0gdGhpcy53b3Jrc3BhY2VOb2RlVG9UZXh0Xyhub2RlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbm9kZS50b1N0cmluZygpO1xuICAgIH1cbiAgICBmaW5hbFRleHQgKz0gdGhpcy5nZXROZXh0T3B0aW9uc18obm9kZSwgb2xkTm9kZSwgaXNNYXJrZXIpO1xuICAgIHJldHVybiBmaW5hbFRleHQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0ZXh0IGV4cGxhaW5pbmcgdGhlIG5leHQgb3B0aW9ucyBhdmFpbGFibGUgZm9yIGEgdXNlci5cbiAgICogQHBhcmFtIHshQmxvY2tseS5BU1ROb2RlfSBub2RlIFRoZSBjdXJyZW50IG5vZGUuXG4gICAqIEBwYXJhbSB7IUJsb2NrbHkuQVNUTm9kZX0gb2xkTm9kZSBUaGUgcHJldmlvdXMgbm9kZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBpc01hcmtlciBUcnVlIGlmIHRoZSBtYXJrZXIgd2FzIG1vdmVkLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRleHQgZXhwbGFpbmluZyBuZXh0IG9wdGlvbnMgZm9yIHRoZSBmaWVsZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldE5leHRPcHRpb25zXyhub2RlLCBvbGROb2RlLCBpc01hcmtlcikge1xuICAgIHN3aXRjaCAobm9kZS5nZXRUeXBlKCkpIHtcbiAgICAgIGNhc2UgQmxvY2tseS5BU1ROb2RlLnR5cGVzLkZJRUxEOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRGaWVsZE9wdGlvbnNfKG5vZGUpO1xuICAgICAgY2FzZSBCbG9ja2x5LkFTVE5vZGUudHlwZXMuQkxPQ0s6XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJsb2NrT3B0aW9uc18obm9kZSk7XG4gICAgICBjYXNlIEJsb2NrbHkuQVNUTm9kZS50eXBlcy5JTlBVVDpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29ubmVjdGlvbk9wdGlvbnNfKG5vZGUsIGlzTWFya2VyKTtcbiAgICAgIGNhc2UgQmxvY2tseS5BU1ROb2RlLnR5cGVzLk9VVFBVVDpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29ubmVjdGlvbk9wdGlvbnNfKG5vZGUsIGlzTWFya2VyKTtcbiAgICAgIGNhc2UgQmxvY2tseS5BU1ROb2RlLnR5cGVzLk5FWFQ6XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbm5lY3Rpb25PcHRpb25zXyhub2RlLCBpc01hcmtlcik7XG4gICAgICBjYXNlIEJsb2NrbHkuQVNUTm9kZS50eXBlcy5QUkVWSU9VUzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29ubmVjdGlvbk9wdGlvbnNfKG5vZGUsIGlzTWFya2VyKTtcbiAgICAgIGNhc2UgQmxvY2tseS5BU1ROb2RlLnR5cGVzLlNUQUNLOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGFja09wdGlvbnNfKG5vZGUpO1xuICAgICAgY2FzZSBCbG9ja2x5LkFTVE5vZGUudHlwZXMuV09SS1NQQUNFOlxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbm9kZS50b1N0cmluZygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBuZXh0IG9wdGlvbnMgZm9yIHdoZW4gYSB1c2VyIGlzIG9uIGEgZmllbGQuXG4gICAqIFRoaXMgaXMgdG8gb3BlbiB0aGUgZmllbGQgb3IgdG8gY2hhbmdlIGxvY2F0aW9ucy5cbiAgICogQHBhcmFtIHshQmxvY2tseS5BU1ROb2RlfSBub2RlIFRoZSBmaWVsZCBub2RlLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB0ZXh0IGV4cGxhaW5pbmcgdGhlIG5leHQgb3B0aW9ucyB3aGVuIGEgdXNlciBpcyBvbiBhXG4gICAqICAgICBmaWVsZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldEZpZWxkT3B0aW9uc18obm9kZSkge1xuICAgIGNvbnN0IGZpZWxkID0gbm9kZS5nZXRMb2NhdGlvbigpO1xuICAgIGlmIChmaWVsZC5pc0NsaWNrYWJsZSgpKSB7XG4gICAgICByZXR1cm4gYFRvIGludGVyYWN0IHdpdGggdGhlIGZpZWxkIGhpdCBlbnRlci4gVXNlIHRoZSBuZXh0IG9yIHByZXZpb3VzXG4gICAgICBrZXlzIHRvIGNoYW5nZSBsb2NhdGlvbnMuIGA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnVXNlIHRoZSBuZXh0IG9yIHByZXZpb3VzIGtleXMgdG8gY2hhbmdlIGxvY2F0aW9ucy4gJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbmV4dCBvcHRpb25zIGZvciB3aGVuIGEgdXNlciBpcyBvbiBhIGJsb2NrLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB0ZXh0IGV4cGxhaW5pbmcgdGhlIG5leHQgb3B0aW9ucyBmb3IgYSBibG9jay5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldEJsb2NrT3B0aW9uc18oKSB7XG4gICAgcmV0dXJuIGBVc2UgdGhlIG5leHQgb3IgcHJldmlvdXMga2V5cyB0byBjaGFuZ2UgbG9jYXRpb25zLiBgO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHRleHQgZm9yIHRoZSBjb25uZWN0aW9uIHBvaW50LlxuICAgKiBAcGFyYW0geyFCbG9ja2x5LkFTVE5vZGV9IG5vZGUgVGhlIGNvbm5lY3Rpb24gbm9kZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBpc01hcmtlciBUcnVlIGlmIHRoZSBtYXJrZXIgd2FzIG1vdmVkLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB0ZXh0IGV4cGxhaW5pbmcgdGhlIG5leHQgb3B0aW9ucyB3aGVuIGEgdXNlciBpcyBvbiBhXG4gICAqICAgICBjb25uZWN0aW9uLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0Q29ubmVjdGlvbk9wdGlvbnNfKG5vZGUsIGlzTWFya2VyKSB7XG4gICAgY29uc3QgbWFya2VyVGV4dCA9IGAuIFRvIG1hcmsgdGhpcyBsb2NhdGlvbiwgaGl0IGVudGVyLiBUbyBjaGFuZ2UgbG9jYXRpb25zIHVzZSB0aGUgbmV4dCBvciBwcmV2aW91cyBrZXlzYDtcbiAgICBsZXQgZmluYWxUZXh0ID0gJyc7XG4gICAgaWYgKCFpc01hcmtlcikge1xuICAgICAgZmluYWxUZXh0ICs9IGAke21hcmtlclRleHR9YDtcbiAgICB9XG4gICAgcmV0dXJuIGZpbmFsVGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBvcHRpb25zIGZvciBhIHVzZXIgb24gYSAgc3RhY2sgb2YgYmxvY2tzLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB0ZXh0IGV4cGxhaW5pbmcgdGhlIG5leHQgb3B0aW9ucyB3aGVuIGEgdXNlciBpcyBvbiBhXG4gICAqICAgICBzdGFjayBvZiBibG9ja3MuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRTdGFja09wdGlvbnNfKG5vZGUpIHtcbiAgICBsZXQgZmluYWxUZXh0ID0gJyc7XG4gICAgaWYgKG5vZGUucHJldigpKSB7XG4gICAgICBmaW5hbFRleHQgKz0gYFRvIGdvIHRvIHRoZSBsYXN0IGJsb2NrIGluIHRoZSBwcmV2aW91cyBncm91cCBvZiBibG9ja3MsXG4gICAgICBwcmVzcyBwcmV2aW91cy5gO1xuICAgIH1cbiAgICBmaW5hbFRleHQgKz0gYCBUbyBnbyB0byB0aGUgZmlyc3QgYmxvY2sgaW4gdGhlIHN0YWNrIGhpdCBuZXh0LmA7XG4gICAgcmV0dXJuIGZpbmFsVGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRleHQgZm9yIHRoZSBzb3VyY2UgYmxvY2sgb2YgdGhlIG5vZGUuXG4gICAqIEBwYXJhbSB7IUJsb2NrbHkuQmxvY2tTdmd9IHNyY0Jsb2NrIFRoZSBibG9jayB0byBnZXQgdGhlIHRleHQgZm9yLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9lbXB0eVRva2VuIFRoZSBvcHRpb25hbCBlbXB0eSB0b2tlbi5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgdGV4dCBkZXNjcmliaW5nIHRoZSBzb3VyY2UgYmxvY2sgb2YgdGhlIG5vZGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRCbG9ja1RleHRfKHNyY0Jsb2NrLCBvcHRfZW1wdHlUb2tlbikge1xuICAgIGxldCBlbXB0eVRva2VuID0gb3B0X2VtcHR5VG9rZW4gfHwgQmxvY2tseS5Nc2dbJ0VNUFRZX1RPS0VOJ107XG4gICAgaWYgKHNyY0Jsb2NrKSB7XG4gICAgICBpZiAoc3JjQmxvY2suc3RhdGVtZW50SW5wdXRDb3VudCA+IDApIHtcbiAgICAgICAgZW1wdHlUb2tlbiA9ICcgZG8gYmxhbmsgJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBzcmNCbG9jay50b1N0cmluZyhudWxsLCBlbXB0eVRva2VuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRleHQgZm9yIGEgZmVpbGQuXG4gICAqIEBwYXJhbSB7IUJsb2NrbHkuQVNUTm9kZX0gbm9kZSBUaGUgbm9kZSB0byBjcmVhdGUgdGV4dCBmb3IuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHRleHQgZm9yIHRoZSBzY3JlZW4gcmVhZGVyIHRvIHJlYWQgb3V0LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBmaWVsZE5vZGVUb1RleHRfKG5vZGUpIHtcbiAgICBjb25zdCBmaWVsZCA9IG5vZGUuZ2V0TG9jYXRpb24oKTtcbiAgICByZXR1cm4gZmllbGQuZ2V0VGV4dCgpICsgJy4gJztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRleHQgZm9yIGEgZmVpbGQuXG4gICAqIEBwYXJhbSB7IUJsb2NrbHkuQVNUTm9kZX0gbm9kZSBUaGUgbm9kZSB0byBjcmVhdGUgdGV4dCBmb3IuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHRleHQgZm9yIHRoZSBzY3JlZW4gcmVhZGVyIHRvIHJlYWQgb3V0LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBibG9ja05vZGVUb1RleHRfKG5vZGUpIHtcbiAgICBjb25zdCBibG9jayA9IC8qKiBAdHlwZXtCbG9ja2x5LkJsb2NrU3ZnfSAqLyAobm9kZS5nZXRMb2NhdGlvbigpKTtcbiAgICBjb25zdCBibG9ja1RleHQgPSB0aGlzLmdldEJsb2NrVGV4dF8oYmxvY2spO1xuICAgIGxldCBmaW5hbFRleHQgPSAnJztcbiAgICBpZiAoYmxvY2suZ2V0U3Vycm91bmRQYXJlbnQoKSkge1xuICAgICAgY29uc3QgcGFyZW50QmxvY2tUZXh0ID0gdGhpcy5nZXRCbG9ja1RleHRfKGJsb2NrLmdldFN1cnJvdW5kUGFyZW50KCkpO1xuICAgICAgZmluYWxUZXh0ICs9IGBZb3UgYXJlIGluc2lkZSBvZiBibG9jayAke3BhcmVudEJsb2NrVGV4dH0uIC4gYDtcbiAgICB9XG4gICAgZmluYWxUZXh0ICs9IGBZb3UgYXJlIG9uICwgJHtibG9ja1RleHR9LiAuIGA7XG4gICAgcmV0dXJuIGZpbmFsVGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRleHQgZm9yIGFuIGlucHV0LlxuICAgKiBAcGFyYW0geyFCbG9ja2x5LkFTVE5vZGV9IG5vZGUgVGhlIG5vZGUgdG8gY3JlYXRlIHRleHQgZm9yLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTWFya2VyIFRydWUgaWYgdGhlIG1hcmtlciB3YXMgbW92ZWQuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHRleHQgZm9yIHRoZSBzY3JlZW4gcmVhZGVyIHRvIHJlYWQgb3V0LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBpbnB1dE5vZGVUb1RleHRfKG5vZGUsIGlzTWFya2VyKSB7XG4gICAgY29uc3QgaW5wdXRDb25uZWN0aW9uID0gLyoqIEB0eXBle0Jsb2NrbHkuSW5wdXR9ICovIChub2RlLmdldExvY2F0aW9uKCkpO1xuICAgIGNvbnN0IGNvbm5lY3Rpb25UZXh0ID0gYFlvdSBhcmUgb24gYSBjb25uZWN0aW9uYDtcbiAgICBsZXQgZmluYWxUZXh0ID0gJyc7XG4gICAgaWYgKGlucHV0Q29ubmVjdGlvbi50eXBlID09PSBCbG9ja2x5Lk5FWFRfU1RBVEVNRU5UKSB7XG4gICAgICBjb25zdCBibG9ja1RleHQgPSB0aGlzLmdldEJsb2NrVGV4dF8obm9kZS5nZXRTb3VyY2VCbG9jaygpKTtcbiAgICAgIGZpbmFsVGV4dCA9IGBJbnNpZGUgJHtibG9ja1RleHR9LiAke2Nvbm5lY3Rpb25UZXh0fS4gYDtcbiAgICB9IGVsc2UgaWYgKGlucHV0Q29ubmVjdGlvbi50eXBlID09PSBCbG9ja2x5LklOUFVUX1ZBTFVFKSB7XG4gICAgICBjb25zdCBibG9ja1RleHQgPSB0aGlzLmdldEJsb2NrVGV4dF8obm9kZS5nZXRTb3VyY2VCbG9jaygpLCAnICcpO1xuICAgICAgZmluYWxUZXh0ID0gYCR7Y29ubmVjdGlvblRleHR9IGFmdGVyICR7YmxvY2tUZXh0fWA7XG4gICAgfVxuICAgIHJldHVybiBmaW5hbFRleHQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyB0ZXh0IGZvciBhIG91dHB1dCBjb25uZWN0aW9uLlxuICAgKiBAcGFyYW0geyFCbG9ja2x5LkFTVE5vZGV9IG5vZGUgVGhlIG5vZGUgdG8gY3JlYXRlIHRleHQgZm9yLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB0ZXh0IGZvciB0aGUgc2NyZWVuIHJlYWRlciB0byByZWFkIG91dC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgb3V0cHV0Tm9kZVRvVGV4dF8obm9kZSkge1xuICAgIGNvbnN0IGJsb2NrVGV4dCA9IHRoaXMuZ2V0QmxvY2tUZXh0Xyhub2RlLmdldFNvdXJjZUJsb2NrKCkpO1xuICAgIHJldHVybiBgWW91IGFyZSBvbiBhIGNvbm5lY3Rpb24gZm9yIGJsb2NrLCAke2Jsb2NrVGV4dH1gO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGV4dCBmb3IgYSBuZXh0IGNvbm5lY3Rpb24uXG4gICAqIEBwYXJhbSB7IUJsb2NrbHkuQVNUTm9kZX0gbm9kZSBUaGUgbm9kZSB0byBjcmVhdGUgdGV4dCBmb3IuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNNYXJrZXIgVHJ1ZSB0byBnZXQgdGhlIHRleHQgZm9yIGEgbWFya2VyLFxuICAgKiAgICAgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB0ZXh0IGZvciB0aGUgc2NyZWVuIHJlYWRlciB0byByZWFkIG91dC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgbmV4dE5vZGVUb1RleHRfKG5vZGUsIGlzTWFya2VyKSB7XG4gICAgY29uc3QgYmxvY2sgPSBub2RlLmdldFNvdXJjZUJsb2NrKCk7XG4gICAgY29uc3QgYmxvY2tUZXh0ID0gdGhpcy5nZXRCbG9ja1RleHRfKG5vZGUuZ2V0U291cmNlQmxvY2soKSk7XG4gICAgbGV0IGZpbmFsVGV4dCA9ICcnO1xuICAgIGlmIChibG9jay5nZXRTdXJyb3VuZFBhcmVudCgpKSB7XG4gICAgICBjb25zdCBwYXJlbnRCbG9ja1RleHQgPSB0aGlzLmdldEJsb2NrVGV4dF8oYmxvY2suZ2V0U3Vycm91bmRQYXJlbnQoKSk7XG4gICAgICBmaW5hbFRleHQgKz0gYFlvdSBhcmUgaW5zaWRlIG9mIGJsb2NrICR7cGFyZW50QmxvY2tUZXh0fS4gLiBgO1xuICAgIH1cbiAgICBmaW5hbFRleHQgKz0gYCR7QmxvY2tseS5Nc2dbJ05FWFQnXX0gJHtibG9ja1RleHR9YDtcbiAgICByZXR1cm4gZmluYWxUZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGV4dCBmb3IgYSBwcmV2aW91cyBjb25uZWN0aW9uLlxuICAgKiBAcGFyYW0geyFCbG9ja2x5LkFTVE5vZGV9IG5vZGUgVGhlIG5vZGUgdG8gY3JlYXRlIHRleHQgZm9yLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTWFya2VyIFRydWUgdG8gZ2V0IHRoZSB0ZXh0IGZvciBhIG1hcmtlcixcbiAgICogICAgIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgdGV4dCBmb3IgdGhlIHNjcmVlbiByZWFkZXIgdG8gcmVhZCBvdXQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHByZXZpb3VzTm9kZVRvVGV4dF8obm9kZSwgaXNNYXJrZXIpIHtcbiAgICBjb25zdCBibG9jayA9IG5vZGUuZ2V0U291cmNlQmxvY2soKTtcbiAgICBjb25zdCBibG9ja1RleHQgPSB0aGlzLmdldEJsb2NrVGV4dF8oYmxvY2spO1xuICAgIGxldCBmaW5hbFRleHQgPSAnJztcbiAgICBpZiAoYmxvY2suZ2V0U3Vycm91bmRQYXJlbnQoKSkge1xuICAgICAgY29uc3QgcGFyZW50QmxvY2tUZXh0ID0gdGhpcy5nZXRCbG9ja1RleHRfKGJsb2NrLmdldFN1cnJvdW5kUGFyZW50KCkpO1xuICAgICAgZmluYWxUZXh0ICs9IGBZb3UgYXJlIGluc2lkZSBvZiBibG9jayAke3BhcmVudEJsb2NrVGV4dH0uIC4gYDtcbiAgICB9XG5cbiAgICBmaW5hbFRleHQgKz0gYCR7QmxvY2tseS5Nc2dbJ1BSRVZJT1VTJ119ICR7YmxvY2tUZXh0fWA7XG4gICAgcmV0dXJuIGZpbmFsVGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRleHQgZm9yIGEgc3RhY2sgb2YgYmxvY2tzLlxuICAgKiBAcGFyYW0geyFCbG9ja2x5LkFTVE5vZGV9IG5vZGUgVGhlIG5vZGUgdG8gY3JlYXRlIHRleHQgZm9yLlxuICAgKiBAcGFyYW0geyFCbG9ja2x5LkFTVE5vZGV9IG9sZE5vZGUgVGhlIHByZXZpb3VzIG5vZGUuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHRleHQgZm9yIHRoZSBzY3JlZW4gcmVhZGVyIHRvIHJlYWQgb3V0LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBzdGFja05vZGVUb1RleHRfKG5vZGUsIG9sZE5vZGUpIHtcbiAgICBjb25zdCBzcmNCbG9jayA9IG5vZGUuZ2V0U291cmNlQmxvY2soKTtcbiAgICBjb25zdCBuZXdOb2RlVG9wQmxvY2sgPSBzcmNCbG9jay5nZXRUb3BTdGFja0Jsb2NrKCk7XG4gICAgbGV0IG9sZE5vZGVUb3BCbG9jayA9IG51bGw7XG4gICAgaWYgKG9sZE5vZGUgJiYgb2xkTm9kZS5nZXRTb3VyY2VCbG9jaygpKSB7XG4gICAgICBvbGROb2RlVG9wQmxvY2sgPSBvbGROb2RlLmdldFNvdXJjZUJsb2NrKCkuZ2V0VG9wU3RhY2tCbG9jaygpO1xuICAgIH1cblxuICAgIGxldCBmaW5hbFRleHQgPSAnJztcblxuICAgIGlmIChzcmNCbG9jayAmJiBzcmNCbG9jay53b3Jrc3BhY2UuaXNGbHlvdXQpIHtcbiAgICAgIGZpbmFsVGV4dCA9IHRoaXMuZ2V0QmxvY2tUZXh0Xyhub2RlLmdldFNvdXJjZUJsb2NrKCkpO1xuICAgICAgZmluYWxUZXh0ICs9IGAgLiAuIFRvIGFkZCB0aGlzIGJsb2NrIHRvIHRoZSB3b3Jrc3BhY2UgcHJlc3MgRW50ZXIuIC5cbiAgICAgIFRvIGdvIHRvIHRoZSBuZXh0IGJsb2NrIGhpdCBuZXh0LiAuIFRvIGdvIGJhY2sgdG8gdGhlIHdvcmtzcGFjZVxuICAgICAgaGl0IGVzY2FwZS4gYDtcbiAgICB9IGVsc2UgaWYgKHNyY0Jsb2NrKSB7XG4gICAgICBpZiAob2xkTm9kZVRvcEJsb2NrICE9PSBuZXdOb2RlVG9wQmxvY2spIHtcbiAgICAgICAgZmluYWxUZXh0ICs9IGBZb3UgYXJlIG9uIGEgbmV3IGdyb3VwIG9mIGJsb2Nrcy4gYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbmFsVGV4dCArPSBgWW91IGFyZSBvbiBhIGdyb3VwIG9mIGJsb2Nrcy4gYDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpbmFsVGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRleHQgZm9yIGEgd29ya3NwYWNlLlxuICAgKiBAcGFyYW0geyFCbG9ja2x5LkFTVE5vZGV9IG5vZGUgVGhlIG5vZGUgdG8gY3JlYXRlIHRleHQgZm9yLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB0ZXh0IGZvciB0aGUgc2NyZWVuIHJlYWRlciB0byByZWFkIG91dC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgd29ya3NwYWNlTm9kZVRvVGV4dF8obm9kZSkge1xuICAgIGNvbnN0IHdvcmtzcGFjZSA9IC8qKiBAdHlwZXtCbG9ja2x5LldvcmtzcGFjZVN2Z30gKi8gKG5vZGUuZ2V0TG9jYXRpb24oKSk7XG4gICAgLy8gVE9ETzogQWxsIHRleHQgc2hvdWxkIGJlIGFkZGVkIHRvIEJsb2NrbHkuTXNnIHRvIGFsbG93IGZvciB0cmFuc2xhdGlvbi5cbiAgICBsZXQgdGV4dCA9IG51bGw7XG4gICAgaWYgKHdvcmtzcGFjZS5pc0ZseW91dCkge1xuICAgICAgdGV4dCA9ICdJbiB0aGUgZmx5b3V0LCBwbGVhc2Ugc2VsZWN0IGEgYmxvY2snO1xuICAgIH0gZWxzZSBpZiAod29ya3NwYWNlLmlzTXV0YXRvcikge1xuICAgICAgdGV4dCA9ICdJbiB0aGUgbXV0YXRvciB3b3Jrc3BhY2UsIHVzZSB0aGlzIHdvcmtzcGFjZSB0byBjaGFuZ2UgYSBibG9jayc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRleHQgPSBCbG9ja2x5Lk1zZ1snTUFJTl9XUyddO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc3BlYWtlciA9IG5ldyBTcGVha2VyKCk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/speaker.js\n");

/***/ })

})